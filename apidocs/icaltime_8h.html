<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Libical API Documentation: icaltime.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Libical API Documentation<span id="projectnumber">&#160;3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_b7a0ea939f6e83384f3c571d31a84be9.html">libical</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">icaltime.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>struct icaltimetype is a pseudo-object that abstracts time handling.  
<a href="#details">More...</a></p>

<p><a href="icaltime_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicaltime__span.html">icaltime_span</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicaltimetype.html">icaltimetype</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aa707f3723c2aa852e398aa480728f6e9"><td class="memItemLeft" align="right" valign="top"><a id="aa707f3723c2aa852e398aa480728f6e9" name="aa707f3723c2aa852e398aa480728f6e9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ICALTIMETYPE_INITIALIZER</b>&#160;&#160;&#160;{ 0, 0, 0, 0, 0, 0, 0, 0, 0}</td></tr>
<tr class="separator:aa707f3723c2aa852e398aa480728f6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598767e5ef2c9303cf6f2441f05e2d40"><td class="memItemLeft" align="right" valign="top"><a id="a598767e5ef2c9303cf6f2441f05e2d40" name="a598767e5ef2c9303cf6f2441f05e2d40"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ICALTIMEZONE_DEFINED</b></td></tr>
<tr class="separator:a598767e5ef2c9303cf6f2441f05e2d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:adb7f14527a82d401994a8e031f831090"><td class="memItemLeft" align="right" valign="top"><a id="adb7f14527a82d401994a8e031f831090" name="adb7f14527a82d401994a8e031f831090"></a>
typedef struct <a class="el" href="structicaltime__span.html">icaltime_span</a>&#160;</td><td class="memItemRight" valign="bottom"><b>icaltime_span</b></td></tr>
<tr class="separator:adb7f14527a82d401994a8e031f831090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81932182c65e1e6ba0e34e105e0a8eb"><td class="memItemLeft" align="right" valign="top"><a id="aa81932182c65e1e6ba0e34e105e0a8eb" name="aa81932182c65e1e6ba0e34e105e0a8eb"></a>
typedef struct <a class="el" href="structicaltimetype.html">icaltimetype</a>&#160;</td><td class="memItemRight" valign="bottom"><b>icaltimetype</b></td></tr>
<tr class="separator:aa81932182c65e1e6ba0e34e105e0a8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8561e9d4374ca1e29cd5ade459a50208"><td class="memItemLeft" align="right" valign="top"><a id="a8561e9d4374ca1e29cd5ade459a50208" name="a8561e9d4374ca1e29cd5ade459a50208"></a>
typedef struct <a class="el" href="struct__icaltimezone.html">_icaltimezone</a>&#160;</td><td class="memItemRight" valign="bottom"><b>icaltimezone</b></td></tr>
<tr class="separator:a8561e9d4374ca1e29cd5ade459a50208"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aeeff97a90d535fd004d93057e49e8663"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icaltime_8h.html#aeeff97a90d535fd004d93057e49e8663">icaltime_adjust</a> (struct <a class="el" href="structicaltimetype.html">icaltimetype</a> *tt, const int days, const int hours, const int minutes, const int seconds)</td></tr>
<tr class="memdesc:aeeff97a90d535fd004d93057e49e8663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal, shouldn't be part of the public API.  <br /></td></tr>
<tr class="separator:aeeff97a90d535fd004d93057e49e8663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d92fa0eb3e7b3cc2f57628d8d2900e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icaltime_8h.html#a96d92fa0eb3e7b3cc2f57628d8d2900e">icaltime_as_ical_string</a> (const struct <a class="el" href="structicaltimetype.html">icaltimetype</a> tt)</td></tr>
<tr class="memdesc:a96d92fa0eb3e7b3cc2f57628d8d2900e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string representation of the time, in RFC5545 format.  <br /></td></tr>
<tr class="separator:a96d92fa0eb3e7b3cc2f57628d8d2900e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3743be95ab23fecba3a1de69ffdc2e"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icaltime_8h.html#aff3743be95ab23fecba3a1de69ffdc2e">icaltime_as_ical_string_r</a> (const struct <a class="el" href="structicaltimetype.html">icaltimetype</a> tt)</td></tr>
<tr class="memdesc:aff3743be95ab23fecba3a1de69ffdc2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string representation of the time, in RFC5545 format.  <br /></td></tr>
<tr class="separator:aff3743be95ab23fecba3a1de69ffdc2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b39742d0f786f41df391c62ee56ec10"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icaltime_8h.html#a7b39742d0f786f41df391c62ee56ec10">icaltime_as_timet</a> (const struct <a class="el" href="structicaltimetype.html">icaltimetype</a>)</td></tr>
<tr class="separator:a7b39742d0f786f41df391c62ee56ec10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec8d0734d00b761745ea55808db8237"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icaltime_8h.html#a4ec8d0734d00b761745ea55808db8237">icaltime_as_timet_with_zone</a> (const struct <a class="el" href="structicaltimetype.html">icaltimetype</a> tt, const <a class="el" href="struct__icaltimezone.html">icaltimezone</a> *zone)</td></tr>
<tr class="memdesc:a4ec8d0734d00b761745ea55808db8237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the time as seconds past the UNIX epoch, using the given timezone.  <br /></td></tr>
<tr class="separator:a4ec8d0734d00b761745ea55808db8237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123759194c6e8c44e1b05193cb61196a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icaltime_8h.html#a123759194c6e8c44e1b05193cb61196a">icaltime_compare</a> (const struct <a class="el" href="structicaltimetype.html">icaltimetype</a> a, const struct <a class="el" href="structicaltimetype.html">icaltimetype</a> b)</td></tr>
<tr class="memdesc:a123759194c6e8c44e1b05193cb61196a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns -1, 0, or 1 to indicate that a is less than b, a equals b, or a is greater than b.  <br /></td></tr>
<tr class="separator:a123759194c6e8c44e1b05193cb61196a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178f667071ea4e8f22140ee8e2f4cdae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icaltime_8h.html#a178f667071ea4e8f22140ee8e2f4cdae">icaltime_compare_date_only</a> (const struct <a class="el" href="structicaltimetype.html">icaltimetype</a> a, const struct <a class="el" href="structicaltimetype.html">icaltimetype</a> b)</td></tr>
<tr class="memdesc:a178f667071ea4e8f22140ee8e2f4cdae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like icaltime_compare, but only use the date parts.  <br /></td></tr>
<tr class="separator:a178f667071ea4e8f22140ee8e2f4cdae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa31574ddedeaf5e5b783b29ce0346d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icaltime_8h.html#abfa31574ddedeaf5e5b783b29ce0346d">icaltime_compare_date_only_tz</a> (const struct <a class="el" href="structicaltimetype.html">icaltimetype</a> a, const struct <a class="el" href="structicaltimetype.html">icaltimetype</a> b, <a class="el" href="struct__icaltimezone.html">icaltimezone</a> *tz)</td></tr>
<tr class="memdesc:abfa31574ddedeaf5e5b783b29ce0346d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like icaltime_compare, but only use the date parts; accepts timezone.  <br /></td></tr>
<tr class="separator:abfa31574ddedeaf5e5b783b29ce0346d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd9b6de943eec5733b74d958951a9c8"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structicaltimetype.html">icaltimetype</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icaltime_8h.html#a9fd9b6de943eec5733b74d958951a9c8">icaltime_convert_to_zone</a> (const struct <a class="el" href="structicaltimetype.html">icaltimetype</a> tt, <a class="el" href="struct__icaltimezone.html">icaltimezone</a> *zone)</td></tr>
<tr class="memdesc:a9fd9b6de943eec5733b74d958951a9c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts time to a given timezone.  <br /></td></tr>
<tr class="separator:a9fd9b6de943eec5733b74d958951a9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ab8c2fdc5766e30d3dd6c873af0151"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structicaltimetype.html">icaltimetype</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icaltime_8h.html#a35ab8c2fdc5766e30d3dd6c873af0151">icaltime_current_time_with_zone</a> (const <a class="el" href="struct__icaltimezone.html">icaltimezone</a> *zone)</td></tr>
<tr class="memdesc:a35ab8c2fdc5766e30d3dd6c873af0151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience constructor.  <br /></td></tr>
<tr class="separator:a35ab8c2fdc5766e30d3dd6c873af0151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df493d8d79b6eef9fca25adefbb6d69"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icaltime_8h.html#a6df493d8d79b6eef9fca25adefbb6d69">icaltime_day_of_week</a> (const struct <a class="el" href="structicaltimetype.html">icaltimetype</a> t)</td></tr>
<tr class="memdesc:a6df493d8d79b6eef9fca25adefbb6d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the day of the week of the given time.  <br /></td></tr>
<tr class="separator:a6df493d8d79b6eef9fca25adefbb6d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39606ca412bb507284a55356c9522b91"><td class="memItemLeft" align="right" valign="top"><a id="a39606ca412bb507284a55356c9522b91" name="a39606ca412bb507284a55356c9522b91"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>icaltime_day_of_year</b> (const struct <a class="el" href="structicaltimetype.html">icaltimetype</a> t)</td></tr>
<tr class="memdesc:a39606ca412bb507284a55356c9522b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the day of the year, counting from 1 (Jan 1st). <br /></td></tr>
<tr class="separator:a39606ca412bb507284a55356c9522b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e9d9e26bea0231d23eb171990a1e8f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icaltime_8h.html#a99e9d9e26bea0231d23eb171990a1e8f">icaltime_days_in_month</a> (const int month, const int year)</td></tr>
<tr class="separator:a99e9d9e26bea0231d23eb171990a1e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50c6fc84b7b70f1678d1771c287b73b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icaltime_8h.html#ac50c6fc84b7b70f1678d1771c287b73b">icaltime_days_in_year</a> (const int year)</td></tr>
<tr class="separator:ac50c6fc84b7b70f1678d1771c287b73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2915233b392cc2a68aa5a9acf39e2307"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structicaltimetype.html">icaltimetype</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icaltime_8h.html#a2915233b392cc2a68aa5a9acf39e2307">icaltime_from_day_of_year</a> (const int doy, const int year)</td></tr>
<tr class="memdesc:a2915233b392cc2a68aa5a9acf39e2307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:a2915233b392cc2a68aa5a9acf39e2307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b66b9f52a9823b95e4cd33f9dd9b8e5"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structicaltimetype.html">icaltimetype</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icaltime_8h.html#a1b66b9f52a9823b95e4cd33f9dd9b8e5">icaltime_from_string</a> (const char *str)</td></tr>
<tr class="memdesc:a1b66b9f52a9823b95e4cd33f9dd9b8e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:a1b66b9f52a9823b95e4cd33f9dd9b8e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a8cb717a14ef07e75060e22711d401"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structicaltimetype.html">icaltimetype</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icaltime_8h.html#a86a8cb717a14ef07e75060e22711d401">icaltime_from_timet_with_zone</a> (const time_t tm, const int is_date, const <a class="el" href="struct__icaltimezone.html">icaltimezone</a> *zone)</td></tr>
<tr class="memdesc:a86a8cb717a14ef07e75060e22711d401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:a86a8cb717a14ef07e75060e22711d401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a59eb5d3951c49e5d62953fcffda3b0"><td class="memItemLeft" align="right" valign="top"><a id="a5a59eb5d3951c49e5d62953fcffda3b0" name="a5a59eb5d3951c49e5d62953fcffda3b0"></a>
const <a class="el" href="struct__icaltimezone.html">icaltimezone</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>icaltime_get_timezone</b> (const struct <a class="el" href="structicaltimetype.html">icaltimetype</a> t)</td></tr>
<tr class="memdesc:a5a59eb5d3951c49e5d62953fcffda3b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the timezone. <br /></td></tr>
<tr class="separator:a5a59eb5d3951c49e5d62953fcffda3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2189e2b4850921f206f87e7112e9e55b"><td class="memItemLeft" align="right" valign="top"><a id="a2189e2b4850921f206f87e7112e9e55b" name="a2189e2b4850921f206f87e7112e9e55b"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>icaltime_get_tzid</b> (const struct <a class="el" href="structicaltimetype.html">icaltimetype</a> t)</td></tr>
<tr class="memdesc:a2189e2b4850921f206f87e7112e9e55b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tzid, or NULL for a floating time. <br /></td></tr>
<tr class="separator:a2189e2b4850921f206f87e7112e9e55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a738950db4a3f2751f414a2a71c1ea4d2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icaltime_8h.html#a738950db4a3f2751f414a2a71c1ea4d2">icaltime_is_date</a> (const struct <a class="el" href="structicaltimetype.html">icaltimetype</a> t)</td></tr>
<tr class="memdesc:a738950db4a3f2751f414a2a71c1ea4d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if time is a DATE.  <br /></td></tr>
<tr class="separator:a738950db4a3f2751f414a2a71c1ea4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb8f16099b25c282dc4f7e33531dae4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icaltime_8h.html#accb8f16099b25c282dc4f7e33531dae4">icaltime_is_leap_year</a> (const int year)</td></tr>
<tr class="memdesc:accb8f16099b25c282dc4f7e33531dae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the specified year is a leap year.  <br /></td></tr>
<tr class="separator:accb8f16099b25c282dc4f7e33531dae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97483d9daf2fc8f8b1bbdc0c75ced095"><td class="memItemLeft" align="right" valign="top"><a id="a97483d9daf2fc8f8b1bbdc0c75ced095" name="a97483d9daf2fc8f8b1bbdc0c75ced095"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>icaltime_is_null_time</b> (const struct <a class="el" href="structicaltimetype.html">icaltimetype</a> t)</td></tr>
<tr class="memdesc:a97483d9daf2fc8f8b1bbdc0c75ced095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the time is null. <br /></td></tr>
<tr class="separator:a97483d9daf2fc8f8b1bbdc0c75ced095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a097e18ea14aceb3dbc68c370f26f9b6c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icaltime_8h.html#a097e18ea14aceb3dbc68c370f26f9b6c">icaltime_is_utc</a> (const struct <a class="el" href="structicaltimetype.html">icaltimetype</a> t)</td></tr>
<tr class="memdesc:a097e18ea14aceb3dbc68c370f26f9b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the time is relative to UTC zone.  <br /></td></tr>
<tr class="separator:a097e18ea14aceb3dbc68c370f26f9b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1991e79202eabe71080a83e1e5c08e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icaltime_8h.html#aaa1991e79202eabe71080a83e1e5c08e">icaltime_is_valid_time</a> (const struct <a class="el" href="structicaltimetype.html">icaltimetype</a> t)</td></tr>
<tr class="memdesc:aaa1991e79202eabe71080a83e1e5c08e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns false if the time is clearly invalid, but is not null.  <br /></td></tr>
<tr class="separator:aaa1991e79202eabe71080a83e1e5c08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02d3d34fd01c3d0e356cea4f789bace"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structicaltimetype.html">icaltimetype</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icaltime_8h.html#ae02d3d34fd01c3d0e356cea4f789bace">icaltime_normalize</a> (const struct <a class="el" href="structicaltimetype.html">icaltimetype</a> tt)</td></tr>
<tr class="memdesc:ae02d3d34fd01c3d0e356cea4f789bace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes the icaltime, so all of the time components are in their normal ranges.  <br /></td></tr>
<tr class="separator:ae02d3d34fd01c3d0e356cea4f789bace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c210823a8ad13687089f12ad285df25"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structicaltimetype.html">icaltimetype</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icaltime_8h.html#a7c210823a8ad13687089f12ad285df25">icaltime_null_date</a> (void)</td></tr>
<tr class="memdesc:a7c210823a8ad13687089f12ad285df25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:a7c210823a8ad13687089f12ad285df25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f088ebb60b8716131742ef16eb7ce1"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structicaltimetype.html">icaltimetype</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icaltime_8h.html#af3f088ebb60b8716131742ef16eb7ce1">icaltime_null_time</a> (void)</td></tr>
<tr class="memdesc:af3f088ebb60b8716131742ef16eb7ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:af3f088ebb60b8716131742ef16eb7ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5c3a433f2919943b42d7d6400f6304"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structicaltimetype.html">icaltimetype</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icaltime_8h.html#aea5c3a433f2919943b42d7d6400f6304">icaltime_set_timezone</a> (struct <a class="el" href="structicaltimetype.html">icaltimetype</a> *t, const <a class="el" href="struct__icaltimezone.html">icaltimezone</a> *zone)</td></tr>
<tr class="memdesc:aea5c3a433f2919943b42d7d6400f6304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the timezone.  <br /></td></tr>
<tr class="separator:aea5c3a433f2919943b42d7d6400f6304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b02dd66ec510ce626aa12395d1fdf79"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icaltime_8h.html#a1b02dd66ec510ce626aa12395d1fdf79">icaltime_span_contains</a> (<a class="el" href="structicaltime__span.html">icaltime_span</a> *s, <a class="el" href="structicaltime__span.html">icaltime_span</a> *container)</td></tr>
<tr class="memdesc:a1b02dd66ec510ce626aa12395d1fdf79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the span is totally within the containing span.  <br /></td></tr>
<tr class="separator:a1b02dd66ec510ce626aa12395d1fdf79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e024d5c8a41b226a31b573d0a86b722"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structicaltime__span.html">icaltime_span</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icaltime_8h.html#a4e024d5c8a41b226a31b573d0a86b722">icaltime_span_new</a> (struct <a class="el" href="structicaltimetype.html">icaltimetype</a> dtstart, struct <a class="el" href="structicaltimetype.html">icaltimetype</a> dtend, int is_busy)</td></tr>
<tr class="memdesc:a4e024d5c8a41b226a31b573d0a86b722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds an icaltimespan given a start time, end time and busy value.  <br /></td></tr>
<tr class="separator:a4e024d5c8a41b226a31b573d0a86b722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a564f5d5c8ebb0746a1799817cfa83"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icaltime_8h.html#a87a564f5d5c8ebb0746a1799817cfa83">icaltime_span_overlaps</a> (<a class="el" href="structicaltime__span.html">icaltime_span</a> *s1, <a class="el" href="structicaltime__span.html">icaltime_span</a> *s2)</td></tr>
<tr class="memdesc:a87a564f5d5c8ebb0746a1799817cfa83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the two spans overlap.  <br /></td></tr>
<tr class="separator:a87a564f5d5c8ebb0746a1799817cfa83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e4ae35fd30b3d2b829f0e5bb7328e31"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icaltime_8h.html#a3e4ae35fd30b3d2b829f0e5bb7328e31">icaltime_start_doy_week</a> (const struct <a class="el" href="structicaltimetype.html">icaltimetype</a> t, int fdow)</td></tr>
<tr class="memdesc:a3e4ae35fd30b3d2b829f0e5bb7328e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the day of the year for the first day of the week that the given time is within.  <br /></td></tr>
<tr class="separator:a3e4ae35fd30b3d2b829f0e5bb7328e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f4440633835d80c182488b11df9372"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structicaltimetype.html">icaltimetype</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icaltime_8h.html#a78f4440633835d80c182488b11df9372">icaltime_today</a> (void)</td></tr>
<tr class="memdesc:a78f4440633835d80c182488b11df9372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience constructor.  <br /></td></tr>
<tr class="separator:a78f4440633835d80c182488b11df9372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be09f07b9444f73a66d179ae61f137a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="icaltime_8h.html#a5be09f07b9444f73a66d179ae61f137a">icaltime_week_number</a> (const struct <a class="el" href="structicaltimetype.html">icaltimetype</a> t)</td></tr>
<tr class="memdesc:a5be09f07b9444f73a66d179ae61f137a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the week number for the week the given time is within.  <br /></td></tr>
<tr class="separator:a5be09f07b9444f73a66d179ae61f137a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>struct icaltimetype is a pseudo-object that abstracts time handling. </p>
<p>It can represent either a DATE or a DATE-TIME (floating, UTC or in a given timezone), and it keeps track internally of its native timezone.</p>
<p>The typical usage is to call the correct constructor specifying the desired timezone. If this is not known until a later time, the correct behavior is to specify a NULL timezone and call <a class="el" href="icaltime_8h.html#a9fd9b6de943eec5733b74d958951a9c8" title="Converts time to a given timezone.">icaltime_convert_to_zone()</a> at a later time.</p>
<p>There are several ways to create a new icaltimetype:</p>
<ul>
<li><a class="el" href="icaltime_8h.html#af3f088ebb60b8716131742ef16eb7ce1" title="Constructor.">icaltime_null_time()</a></li>
<li><a class="el" href="icaltime_8h.html#a7c210823a8ad13687089f12ad285df25" title="Constructor.">icaltime_null_date()</a></li>
<li><a class="el" href="icaltime_8h.html#a35ab8c2fdc5766e30d3dd6c873af0151" title="Convenience constructor.">icaltime_current_time_with_zone()</a></li>
<li><a class="el" href="icaltime_8h.html#a78f4440633835d80c182488b11df9372" title="Convenience constructor.">icaltime_today()</a></li>
<li>icaltime_from_timet_with_zone(time_t tm, int is_date,
        icaltimezone *zone)</li>
<li><a class="el" href="icaltime_8h.html#a2915233b392cc2a68aa5a9acf39e2307" title="Constructor.">icaltime_from_day_of_year(int doy, int year)</a></li>
</ul>
<p>italtimetype objects can be converted to different formats:</p>
<ul>
<li><a class="el" href="icaltime_8h.html#a7b39742d0f786f41df391c62ee56ec10">icaltime_as_timet(struct icaltimetype tt)</a></li>
<li>icaltime_as_timet_with_zone(struct icaltimetype tt,
        icaltimezone *zone)</li>
<li><a class="el" href="icaltime_8h.html#a96d92fa0eb3e7b3cc2f57628d8d2900e" title="Returns a string representation of the time, in RFC5545 format.">icaltime_as_ical_string(struct icaltimetype tt)</a></li>
</ul>
<p>Accessor methods include:</p>
<ul>
<li><a class="el" href="icaltime_8h.html#a5a59eb5d3951c49e5d62953fcffda3b0" title="Returns the timezone.">icaltime_get_timezone(struct icaltimetype t)</a></li>
<li><a class="el" href="icaltime_8h.html#a2189e2b4850921f206f87e7112e9e55b" title="Returns the tzid, or NULL for a floating time.">icaltime_get_tzid(struct icaltimetype t)</a></li>
<li>icaltime_set_timezone(struct icaltimetype t, const icaltimezone *zone)</li>
<li><a class="el" href="icaltime_8h.html#a39606ca412bb507284a55356c9522b91" title="Returns the day of the year, counting from 1 (Jan 1st).">icaltime_day_of_year(struct icaltimetype t)</a></li>
<li><a class="el" href="icaltime_8h.html#a6df493d8d79b6eef9fca25adefbb6d69" title="Returns the day of the week of the given time.">icaltime_day_of_week(struct icaltimetype t)</a></li>
<li><a class="el" href="icaltime_8h.html#a3e4ae35fd30b3d2b829f0e5bb7328e31" title="Returns the day of the year for the first day of the week that the given time is within.">icaltime_start_doy_week(struct icaltimetype t, int fdow)</a></li>
<li><a class="el" href="icaltime_8h.html#a5be09f07b9444f73a66d179ae61f137a" title="Returns the week number for the week the given time is within.">icaltime_week_number(struct icaltimetype t)</a></li>
</ul>
<p>Query methods include:</p>
<ul>
<li><a class="el" href="icaltime_8h.html#a97483d9daf2fc8f8b1bbdc0c75ced095" title="Returns true if the time is null.">icaltime_is_null_time(struct icaltimetype t)</a></li>
<li><a class="el" href="icaltime_8h.html#aaa1991e79202eabe71080a83e1e5c08e" title="Returns false if the time is clearly invalid, but is not null.">icaltime_is_valid_time(struct icaltimetype t)</a></li>
<li><a class="el" href="icaltime_8h.html#a738950db4a3f2751f414a2a71c1ea4d2" title="Returns true if time is a DATE.">icaltime_is_date(struct icaltimetype t)</a></li>
<li><a class="el" href="icaltime_8h.html#a097e18ea14aceb3dbc68c370f26f9b6c" title="Returns true if the time is relative to UTC zone.">icaltime_is_utc(struct icaltimetype t)</a></li>
</ul>
<p>Modify, compare and utility methods include:</p>
<ul>
<li><a class="el" href="icaltime_8h.html#a123759194c6e8c44e1b05193cb61196a" title="Returns -1, 0, or 1 to indicate that a is less than b, a equals b, or a is greater than b.">icaltime_compare(struct icaltimetype a,struct icaltimetype b)</a></li>
<li><a class="el" href="icaltime_8h.html#a178f667071ea4e8f22140ee8e2f4cdae" title="Like icaltime_compare, but only use the date parts.">icaltime_compare_date_only(struct icaltimetype a,
        struct icaltimetype b)</a></li>
<li><a class="el" href="icaltime_8h.html#aeeff97a90d535fd004d93057e49e8663" title="Internal, shouldn&#39;t be part of the public API.">icaltime_adjust(struct icaltimetype *tt, int days, int hours,
        int minutes, int seconds)</a>;</li>
<li><a class="el" href="icaltime_8h.html#ae02d3d34fd01c3d0e356cea4f789bace" title="Normalizes the icaltime, so all of the time components are in their normal ranges.">icaltime_normalize(struct icaltimetype t)</a>;</li>
<li><a class="el" href="icaltime_8h.html#a9fd9b6de943eec5733b74d958951a9c8" title="Converts time to a given timezone.">icaltime_convert_to_zone(const struct icaltimetype tt,
        icaltimezone *zone)</a>; </li>
</ul>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aeeff97a90d535fd004d93057e49e8663" name="aeeff97a90d535fd004d93057e49e8663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeff97a90d535fd004d93057e49e8663">&#9670;&#160;</a></span>icaltime_adjust()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void icaltime_adjust </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structicaltimetype.html">icaltimetype</a> *&#160;</td>
          <td class="paramname"><em>tt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>days</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>hours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>minutes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>seconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal, shouldn't be part of the public API. </p>
<p>Adds or subtracts a number of days, hours, minutes and seconds. </p>
<p>Adds or subtracts a time from a icaltimetype. This time is given as a number of days, hours, minutes and seconds.</p>
<dl class="section note"><dt>Note</dt><dd>This function is exactly the same as icaltimezone_adjust_change() except for the type of the first parameter. </dd></dl>

</div>
</div>
<a id="a96d92fa0eb3e7b3cc2f57628d8d2900e" name="a96d92fa0eb3e7b3cc2f57628d8d2900e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96d92fa0eb3e7b3cc2f57628d8d2900e">&#9670;&#160;</a></span>icaltime_as_ical_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * icaltime_as_ical_string </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structicaltimetype.html">icaltimetype</a>&#160;</td>
          <td class="paramname"><em>tt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string representation of the time, in RFC5545 format. </p>
<dl class="section user"><dt>Ownership</dt><dd>The created string is owned by libical. </dd></dl>

</div>
</div>
<a id="aff3743be95ab23fecba3a1de69ffdc2e" name="aff3743be95ab23fecba3a1de69ffdc2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff3743be95ab23fecba3a1de69ffdc2e">&#9670;&#160;</a></span>icaltime_as_ical_string_r()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * icaltime_as_ical_string_r </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structicaltimetype.html">icaltimetype</a>&#160;</td>
          <td class="paramname"><em>tt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string representation of the time, in RFC5545 format. </p>
<dl class="section user"><dt>Ownership</dt><dd>The string is owned by the caller. </dd></dl>

</div>
</div>
<a id="a7b39742d0f786f41df391c62ee56ec10" name="a7b39742d0f786f41df391c62ee56ec10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b39742d0f786f41df391c62ee56ec10">&#9670;&#160;</a></span>icaltime_as_timet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t icaltime_as_timet </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structicaltimetype.html">icaltimetype</a>&#160;</td>
          <td class="paramname"><em>tt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the time as seconds past the UNIX epoch.</p>
<p>This function probably won't do what you expect. In particular, you should only pass an icaltime in UTC, since no conversion is done. Even in that case, it's probably better to just use <a class="el" href="icaltime_8h.html#a4ec8d0734d00b761745ea55808db8237" title="Returns the time as seconds past the UNIX epoch, using the given timezone.">icaltime_as_timet_with_zone()</a>.</p>
<p>The return value is defined for dates ranging from 1902-01-01 (incl.) up to 10000-01-01 (excl.) if time_t has a size of 64 bit and up to 2038-01-18 (excl.) if it has a size of 32 bit. </p>

</div>
</div>
<a id="a4ec8d0734d00b761745ea55808db8237" name="a4ec8d0734d00b761745ea55808db8237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec8d0734d00b761745ea55808db8237">&#9670;&#160;</a></span>icaltime_as_timet_with_zone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t icaltime_as_timet_with_zone </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structicaltimetype.html">icaltimetype</a>&#160;</td>
          <td class="paramname"><em>tt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct__icaltimezone.html">icaltimezone</a> *&#160;</td>
          <td class="paramname"><em>zone</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the time as seconds past the UNIX epoch, using the given timezone. </p>
<p>This convenience method combines a call to <a class="el" href="icaltime_8h.html#a9fd9b6de943eec5733b74d958951a9c8" title="Converts time to a given timezone.">icaltime_convert_to_zone()</a> with a call to <a class="el" href="icaltime_8h.html#a7b39742d0f786f41df391c62ee56ec10">icaltime_as_timet()</a>. If the input timezone is null, no conversion is done; that is, the time is simply returned as time_t in its native timezone. </p>

</div>
</div>
<a id="a123759194c6e8c44e1b05193cb61196a" name="a123759194c6e8c44e1b05193cb61196a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a123759194c6e8c44e1b05193cb61196a">&#9670;&#160;</a></span>icaltime_compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int icaltime_compare </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structicaltimetype.html">icaltimetype</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structicaltimetype.html">icaltimetype</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns -1, 0, or 1 to indicate that a is less than b, a equals b, or a is greater than b. </p>
<p>This converts both times to the UTC timezone and compares them. </p>

</div>
</div>
<a id="a178f667071ea4e8f22140ee8e2f4cdae" name="a178f667071ea4e8f22140ee8e2f4cdae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a178f667071ea4e8f22140ee8e2f4cdae">&#9670;&#160;</a></span>icaltime_compare_date_only()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int icaltime_compare_date_only </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structicaltimetype.html">icaltimetype</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structicaltimetype.html">icaltimetype</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like icaltime_compare, but only use the date parts. </p>
<p>This converts both times to the UTC timezone and compares their date components. </p>

</div>
</div>
<a id="abfa31574ddedeaf5e5b783b29ce0346d" name="abfa31574ddedeaf5e5b783b29ce0346d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfa31574ddedeaf5e5b783b29ce0346d">&#9670;&#160;</a></span>icaltime_compare_date_only_tz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int icaltime_compare_date_only_tz </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structicaltimetype.html">icaltimetype</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structicaltimetype.html">icaltimetype</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__icaltimezone.html">icaltimezone</a> *&#160;</td>
          <td class="paramname"><em>tz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like icaltime_compare, but only use the date parts; accepts timezone. </p>
<p>This converts both times to the given timezone and compares their date components. </p>

</div>
</div>
<a id="a9fd9b6de943eec5733b74d958951a9c8" name="a9fd9b6de943eec5733b74d958951a9c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd9b6de943eec5733b74d958951a9c8">&#9670;&#160;</a></span>icaltime_convert_to_zone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structicaltimetype.html">icaltimetype</a> icaltime_convert_to_zone </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structicaltimetype.html">icaltimetype</a>&#160;</td>
          <td class="paramname"><em>tt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__icaltimezone.html">icaltimezone</a> *&#160;</td>
          <td class="paramname"><em>zone</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts time to a given timezone. </p>
<p>Converts a time from its native timezone to a given timezone.</p>
<p>If <code>tt</code> is a date, the timezone is not converted and the returned time is an exact copy of <code>tt</code>.</p>
<p>If it's a floating time, the returned object represents the same time relative to <code>zone</code>. For example, if <code>tt</code> represents 9:30 AM floating and <code>zone</code> is the GMT timezone, the returned object will represent 9:30 AM GMT.</p>
<p>Otherwise, the time will be converted to <code>zone</code>, and its timezone property updated to <code>zone</code>. For example, July 20 1969, 8:17 PM UTC would be converted to July 20 1969, 4:17 PM EDT. </p>

</div>
</div>
<a id="a35ab8c2fdc5766e30d3dd6c873af0151" name="a35ab8c2fdc5766e30d3dd6c873af0151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35ab8c2fdc5766e30d3dd6c873af0151">&#9670;&#160;</a></span>icaltime_current_time_with_zone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structicaltimetype.html">icaltimetype</a> icaltime_current_time_with_zone </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__icaltimezone.html">icaltimezone</a> *&#160;</td>
          <td class="paramname"><em>zone</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience constructor. </p>
<dl class="section return"><dt>Returns</dt><dd>The current time in the given timezone, as an icaltimetype. </dd></dl>

</div>
</div>
<a id="a6df493d8d79b6eef9fca25adefbb6d69" name="a6df493d8d79b6eef9fca25adefbb6d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df493d8d79b6eef9fca25adefbb6d69">&#9670;&#160;</a></span>icaltime_day_of_week()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int icaltime_day_of_week </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structicaltimetype.html">icaltimetype</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the day of the week of the given time. </p>
<p>Sunday is 1, and Saturday is 7. </p>

</div>
</div>
<a id="a99e9d9e26bea0231d23eb171990a1e8f" name="a99e9d9e26bea0231d23eb171990a1e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99e9d9e26bea0231d23eb171990a1e8f">&#9670;&#160;</a></span>icaltime_days_in_month()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int icaltime_days_in_month </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>month</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>year</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of days in the given month. </p>

</div>
</div>
<a id="ac50c6fc84b7b70f1678d1771c287b73b" name="ac50c6fc84b7b70f1678d1771c287b73b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac50c6fc84b7b70f1678d1771c287b73b">&#9670;&#160;</a></span>icaltime_days_in_year()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int icaltime_days_in_year </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>year</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of days in this year. </p>

</div>
</div>
<a id="a2915233b392cc2a68aa5a9acf39e2307" name="a2915233b392cc2a68aa5a9acf39e2307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2915233b392cc2a68aa5a9acf39e2307">&#9670;&#160;</a></span>icaltime_from_day_of_year()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structicaltimetype.html">icaltimetype</a> icaltime_from_day_of_year </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>doy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>year</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Creates a new time, given a day of year and a year.</p>
<p>Note that Jan 1 is day #1, not 0. </p>

</div>
</div>
<a id="a1b66b9f52a9823b95e4cd33f9dd9b8e5" name="a1b66b9f52a9823b95e4cd33f9dd9b8e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b66b9f52a9823b95e4cd33f9dd9b8e5">&#9670;&#160;</a></span>icaltime_from_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structicaltimetype.html">icaltimetype</a> icaltime_from_string </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Creates a time from an ISO format string.</p>

</div>
</div>
<a id="a86a8cb717a14ef07e75060e22711d401" name="a86a8cb717a14ef07e75060e22711d401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a8cb717a14ef07e75060e22711d401">&#9670;&#160;</a></span>icaltime_from_timet_with_zone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structicaltimetype.html">icaltimetype</a> icaltime_from_timet_with_zone </td>
          <td>(</td>
          <td class="paramtype">const time_t&#160;</td>
          <td class="paramname"><em>tm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>is_date</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct__icaltimezone.html">icaltimezone</a> *&#160;</td>
          <td class="paramname"><em>zone</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tm</td><td>The time expressed as seconds past UNIX epoch </td></tr>
    <tr><td class="paramname">is_date</td><td>Boolean: 1 means we should treat tm as a DATE </td></tr>
    <tr><td class="paramname">zone</td><td>The timezone tm is in, NULL means to treat tm as a floating time</td></tr>
  </table>
  </dd>
</dl>
<p>Returns a new icaltime instance, initialized to the given time, optionally using the given timezone.</p>
<p>If the caller specifies the is_date param as TRUE, the returned object is of DATE type, otherwise the input is meant to be of DATE-TIME type. If the zone is not specified (NULL zone param) the time is taken to be floating, that is, valid in any timezone. Note that, in addition to the uses specified in [RFC5545], this can be used when doing simple math on couples of times. If the zone is specified (UTC or otherwise), it's stored in the object and it's used as the native timezone for this object. This means that the caller can convert this time to a different target timezone with no need to store the source timezone. </p>

</div>
</div>
<a id="a738950db4a3f2751f414a2a71c1ea4d2" name="a738950db4a3f2751f414a2a71c1ea4d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a738950db4a3f2751f414a2a71c1ea4d2">&#9670;&#160;</a></span>icaltime_is_date()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int icaltime_is_date </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structicaltimetype.html">icaltimetype</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if time is a DATE. </p>
<p>The options are DATE type, which returns true, or DATE-TIME, which returns false. </p>

</div>
</div>
<a id="accb8f16099b25c282dc4f7e33531dae4" name="accb8f16099b25c282dc4f7e33531dae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accb8f16099b25c282dc4f7e33531dae4">&#9670;&#160;</a></span>icaltime_is_leap_year()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int icaltime_is_leap_year </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>year</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the specified year is a leap year. </p>
<p>Year is the normal year, e.g. 2001. </p>

</div>
</div>
<a id="a097e18ea14aceb3dbc68c370f26f9b6c" name="a097e18ea14aceb3dbc68c370f26f9b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a097e18ea14aceb3dbc68c370f26f9b6c">&#9670;&#160;</a></span>icaltime_is_utc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int icaltime_is_utc </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structicaltimetype.html">icaltimetype</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the time is relative to UTC zone. </p>

</div>
</div>
<a id="aaa1991e79202eabe71080a83e1e5c08e" name="aaa1991e79202eabe71080a83e1e5c08e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa1991e79202eabe71080a83e1e5c08e">&#9670;&#160;</a></span>icaltime_is_valid_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int icaltime_is_valid_time </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structicaltimetype.html">icaltimetype</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns false if the time is clearly invalid, but is not null. </p>
<p>This is usually the result of creating a new time type but not clearing it, or setting one of the flags to an illegal value. </p>

</div>
</div>
<a id="ae02d3d34fd01c3d0e356cea4f789bace" name="ae02d3d34fd01c3d0e356cea4f789bace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae02d3d34fd01c3d0e356cea4f789bace">&#9670;&#160;</a></span>icaltime_normalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structicaltimetype.html">icaltimetype</a> icaltime_normalize </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structicaltimetype.html">icaltimetype</a>&#160;</td>
          <td class="paramname"><em>tt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes the icaltime, so all of the time components are in their normal ranges. </p>
<p>For instance, given a time with minutes=70, the minutes will be reduces to 10, and the hour incremented. This allows the caller to do arithmetic on times without worrying about overflow or underflow. </p>

</div>
</div>
<a id="a7c210823a8ad13687089f12ad285df25" name="a7c210823a8ad13687089f12ad285df25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c210823a8ad13687089f12ad285df25">&#9670;&#160;</a></span>icaltime_null_date()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structicaltimetype.html">icaltimetype</a> icaltime_null_date </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="section return"><dt>Returns</dt><dd>A null date, which indicates no time has been set. </dd></dl>

</div>
</div>
<a id="af3f088ebb60b8716131742ef16eb7ce1" name="af3f088ebb60b8716131742ef16eb7ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3f088ebb60b8716131742ef16eb7ce1">&#9670;&#160;</a></span>icaltime_null_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structicaltimetype.html">icaltimetype</a> icaltime_null_time </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="section return"><dt>Returns</dt><dd>A null time, which indicates no time has been set. This time represents the beginning of the epoch. </dd></dl>

</div>
</div>
<a id="aea5c3a433f2919943b42d7d6400f6304" name="aea5c3a433f2919943b42d7d6400f6304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea5c3a433f2919943b42d7d6400f6304">&#9670;&#160;</a></span>icaltime_set_timezone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structicaltimetype.html">icaltimetype</a> icaltime_set_timezone </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structicaltimetype.html">icaltimetype</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct__icaltimezone.html">icaltimezone</a> *&#160;</td>
          <td class="paramname"><em>zone</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the timezone. </p>
<p>Forces the icaltime to be interpreted relative to another timezone. The returned time represents the same time as <code>t</code>, but relative to the new <code>zone</code>. For example, modifying July 20 1969, 8:17 PM UTC to the EDT time zone would return a time representing July 20 1969, 8:17 PM EDT.</p>
<p>If you need to do timezone conversion, applying offset adjustments, then you should use icaltime_convert_to_zone instead.</p>
<p>If <code>t</code> is of type <code>DATE</code>, its timezone is not modified and the returned time is an exact copy of <code>t</code>. </p>

</div>
</div>
<a id="a1b02dd66ec510ce626aa12395d1fdf79" name="a1b02dd66ec510ce626aa12395d1fdf79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b02dd66ec510ce626aa12395d1fdf79">&#9670;&#160;</a></span>icaltime_span_contains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int icaltime_span_contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structicaltime__span.html">icaltime_span</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structicaltime__span.html">icaltime_span</a> *&#160;</td>
          <td class="paramname"><em>container</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the span is totally within the containing span. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The span to test for. </td></tr>
    <tr><td class="paramname">container</td><td>The span to test against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean value. </dd></dl>

</div>
</div>
<a id="a4e024d5c8a41b226a31b573d0a86b722" name="a4e024d5c8a41b226a31b573d0a86b722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e024d5c8a41b226a31b573d0a86b722">&#9670;&#160;</a></span>icaltime_span_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structicaltime__span.html">icaltime_span</a> icaltime_span_new </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structicaltimetype.html">icaltimetype</a>&#160;</td>
          <td class="paramname"><em>dtstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structicaltimetype.html">icaltimetype</a>&#160;</td>
          <td class="paramname"><em>dtend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>is_busy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds an icaltimespan given a start time, end time and busy value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dtstart</td><td>The beginning time of the span, can be a date-time or just a date. </td></tr>
    <tr><td class="paramname">dtend</td><td>The end time of the span. </td></tr>
    <tr><td class="paramname">is_busy</td><td>A boolean value, 0/1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A span using the supplied values. The times are specified in UTC. </dd></dl>

</div>
</div>
<a id="a87a564f5d5c8ebb0746a1799817cfa83" name="a87a564f5d5c8ebb0746a1799817cfa83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a564f5d5c8ebb0746a1799817cfa83">&#9670;&#160;</a></span>icaltime_span_overlaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int icaltime_span_overlaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structicaltime__span.html">icaltime_span</a> *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structicaltime__span.html">icaltime_span</a> *&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the two spans overlap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>First span to test </td></tr>
    <tr><td class="paramname">s2</td><td>Second span to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean value</dd></dl>
<p>The result is calculated by testing if the start time of s1 is contained by the s2 span, or if the end time of s1 is contained by the s2 span.</p>
<p>Also returns true if the spans are equal.</p>
<p>Note, this will return false if the spans are adjacent. </p>

</div>
</div>
<a id="a3e4ae35fd30b3d2b829f0e5bb7328e31" name="a3e4ae35fd30b3d2b829f0e5bb7328e31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e4ae35fd30b3d2b829f0e5bb7328e31">&#9670;&#160;</a></span>icaltime_start_doy_week()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int icaltime_start_doy_week </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structicaltimetype.html">icaltimetype</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fdow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the day of the year for the first day of the week that the given time is within. </p>
<p>Returns the day of the year for the first day of the week . </p>
<p>This uses the first day of the week that contains the given time, which is a Sunday. It returns the day of the year for the resulting day. </p>

</div>
</div>
<a id="a78f4440633835d80c182488b11df9372" name="a78f4440633835d80c182488b11df9372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78f4440633835d80c182488b11df9372">&#9670;&#160;</a></span>icaltime_today()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structicaltimetype.html">icaltimetype</a> icaltime_today </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience constructor. </p>
<dl class="section return"><dt>Returns</dt><dd>The current day as an icaltimetype, with is_date set. </dd></dl>

</div>
</div>
<a id="a5be09f07b9444f73a66d179ae61f137a" name="a5be09f07b9444f73a66d179ae61f137a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5be09f07b9444f73a66d179ae61f137a">&#9670;&#160;</a></span>icaltime_week_number()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int icaltime_week_number </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structicaltimetype.html">icaltimetype</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the week number for the week the given time is within. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Mar 31 2024 06:42:58 for Libical API Documentation by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
