<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Libical Manual</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Libical Manual</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="libical--an-implementation-of-icalendar-protocols-and-data-formats"><a class="header" href="#libical--an-implementation-of-icalendar-protocols-and-data-formats">Libical — an implementation of iCalendar protocols and data formats</a></h1>
<p><a href="https://github.com/libical/libical/actions"><img src="https://github.com/libical/libical/actions/workflows/build.yml/badge.svg" alt="Github workflow" /></a>
<a href="https://repology.org/metapackage/libical"><img src="https://repology.org/badge/tiny-repos/libical.svg" alt="Packaging status" /></a></p>
<h2 id="about"><a class="header" href="#about">About</a></h2>
<p>Libical — an implementation of iCalendar protocols and data formats</p>
<p>Most of the code in here was written by Eric Busboom at the end
of the last millennium with help from dozens of contributors.
It is currently maintained by Allen Winter and the libical team
at <a href="https://libical.github.io/libical">https://libical.github.io/libical</a>.</p>
<p>Libical is an Open Source implementation of the iCalendar protocols
and protocol data units. The iCalendar specification describes how
calendar clients can communicate with calendar servers so users can
store their calendar data and arrange meetings with other users.</p>
<p>Thanks to our <a href="CONTRIBUTORS.html">contributors</a>.</p>
<h2 id="rfcs"><a class="header" href="#rfcs">RFCs</a></h2>
<p>See <a href="docs/rfcs.html">RFC calendar standards</a> for list of RFCs supported by this library.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>The code and datafiles in this distribution are licensed under the
Mozilla Public License (MPL) v2.0. See <a href="https://www.mozilla.org/MPL">https://www.mozilla.org/MPL</a>
for a copy of this license.</p>
<p>Alternately, you may use libical under the terms of the GNU Lesser
General Public License (LGPL) v2.1. See <a href="https://www.gnu.org/licenses/lgpl-2.1.txt">https://www.gnu.org/licenses/lgpl-2.1.txt</a>
for a copy of this license.</p>
<p>This dual license ensures that the library can be incorporated into
both proprietary code and GPL'd programs, and will benefit from improvements
made by programmers in both realms. We (the libical developers) will only
accept changes to this library if they are similarly dual-licensed.</p>
<h2 id="building"><a class="header" href="#building">Building</a></h2>
<p>See the top-level <a href="Install.txt">Install.txt</a> file.</p>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<p>See the <a href="https://libical.github.io/libical/apidocs/">C API documentation</a> and
<a href="https://libical.github.io/libical/libical-glib/">glibc API documentation</a>.</p>
<p>For a conceptual overview of the library, see <a href="docs/UsingLibical.html">Using Libical</a>.
There is other rudimentary, unfinished documentation in the <code>docs/</code> directory of the
source distribution, annotated examples in <code>examples/</code> and the test code in <code>src/test/</code>.</p>
<p>For developers porting their code to libical version 4, please visit the
<a href="docs/MigrationGuide_to_4.html">Version 4 Migration Guide</a>.</p>
<h2 id="acknowledgments"><a class="header" href="#acknowledgments">Acknowledgments</a></h2>
<p>Portions of this distribution are (C) Copyright 1996 Apple Computer,Inc., AT&amp;T Corp.,
International Business Machines Corporation and Siemens Rolm Communications Inc.
See <a href="src/libicalvcal/README.txt">src/libicalvcal/README.TXT</a> for details.</p>
<h2 id="libical-users"><a class="header" href="#libical-users">Libical Users</a></h2>
<p>In no particular order:</p>
<ul>
<li><a href="https://www.cyrusimap.org">Cyrus Email/Calendars/Contacts Server</a></li>
<li><a href="https://syncevolution.org">syncEvolution</a></li>
<li><a href="https://flexibits.com/fantastical">Fantastical</a></li>
<li>GNOME's EDS (evolution-data-server) which serves data to:
<ul>
<li><a href="https://wiki.gnome.org/Apps/Evolution">Evolution</a></li>
<li><a href="https://wiki.gnome.org/Apps/Calendar">GNOME Calendar</a></li>
<li><a href="https://wiki.gnome.org/Apps/Notes">GNOME Notes</a></li>
<li><a href="https://wiki.gnome.org/Apps/Todo">GNOME Todo</a></li>
<li>and more GNOME apps...</li>
</ul>
</li>
<li>KDE's <a href="https://kontact.kde.org">Kontact Suite</a> including:
<ul>
<li><a href="https://kontact.kde.org/components/akonadi.html">Akonadi framework</a></li>
<li><a href="https://kontact.kde.org/components/korganizer.html">KOrganizer calendar and scheduling component</a></li>
<li>and more KDE apps...</li>
</ul>
</li>
</ul>
<h2 id="get-involved"><a class="header" href="#get-involved">Get Involved</a></h2>
<p>Watch the github project at <a href="https://github.com/libical/libical">https://github.com/libical/libical</a></p>
<p>Follow discussions and announcements at
<a href="https://github.com/libical/libical/discussions">https://github.com/libical/libical/discussions</a></p>
<p>Report bugs to our issue tracker at
<a href="https://github.com/libical/libical/issues">https://github.com/libical/libical/issues</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h1>
<h2 id="required"><a class="header" href="#required">Required</a></h2>
<ul>
<li>CMake version 3.20 or above</li>
<li>A fully C99 standards complaint C compiler</li>
<li>Perl</li>
</ul>
<h2 id="highly-recommended"><a class="header" href="#highly-recommended">Highly Recommended</a></h2>
<p>For the C++ bindings a fully C++11 standards compliant C++ compiler</p>
<p>For RSCALE support the libicu development package is needed.</p>
<h2 id="glib-bindings"><a class="header" href="#glib-bindings">GLib Bindings</a></h2>
<ul>
<li>pkgconfig</li>
<li>gobject-introspection (-devel)</li>
<li>libxml2 (-devel)</li>
<li>python3</li>
</ul>
<p>and to build the associated GLib bindings documentation you'll need;</p>
<ul>
<li>gi-docgen</li>
</ul>
<p>in addition, to build the Vala support you'll also need:</p>
<ul>
<li>vala (valac, the Vala compiler)</li>
</ul>
<h2 id="optional-dependencies"><a class="header" href="#optional-dependencies">Optional dependencies</a></h2>
<ul>
<li>berkeleydb (-devel) for Berkeley DB storage support in libicalss</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-libical"><a class="header" href="#using-libical">Using Libical</a></h1>
<blockquote>
<p>Author: Eric Busboom <a href="mailto:eric@civicknowledge.com">eric@civicknowledge.com</a></p>
<p>Date: January 2001</p>
</blockquote>
<h2 id="1-introduction"><a class="header" href="#1-introduction">1 Introduction</a></h2>
<p>Libical is an Open Source implementation of the iCalendar protocols
and protocol data units. The iCalendar specification describes how
calendar clients can communicate with calendar servers so users can
store their calendar data and arrange meetings with other users.</p>
<p>Libical implements multiple <a href="rfcs.html">RFC calendar standards</a>.</p>
<p>This documentation assumes that you are familiar with the iCalendar
standards <a href="https://tools.ietf.org/html/rfc5545">RFC5545</a> and <a href="https://tools.ietf.org/html/rfc5546">RFC5546</a>. These specifications are available
at the <a href="https://tools.ietf.org/">IETF Tools</a> website:</p>
<h3 id="11-the-libical-project"><a class="header" href="#11-the-libical-project">1.1 The libical project</a></h3>
<p>This code is under active development. If you would like to contribute
to the project, visit <a href="https://libical.github.io/libical/">https://libical.github.io/libical/</a>.</p>
<h3 id="12-license"><a class="header" href="#12-license">1.2 License</a></h3>
<p>The code and datafiles in this distribution are licensed under the
Mozilla Public License version 2.0. See <a href="https://www.mozilla.org/MPL">https://www.mozilla.org/MPL</a>
for a copy of the license. Alternately, you may use libical under
the terms of the GNU Lesser General Public License, version 2.1.
See <a href="https://www.gnu.org/licenses/lgpl-2.1.html">https://www.gnu.org/licenses/lgpl-2.1.html</a> for a copy of the LGPL.</p>
<p>This dual license ensures that the library can be incorporated into
both proprietary code and GPL'd programs, and will benefit from improvements
made by programmers in both realms. We (the libical developers) will only
accept changes to this library if they are similarly dual-licensed.</p>
<h3 id="13-example-code"><a class="header" href="#13-example-code">1.3 Example Code</a></h3>
<p>A lot of the documentation for this library is in the form of example
code. These examples are in the <code>examples/</code> directory of the distribution.
Also look in <code>src/test/</code> for additional annotated examples.</p>
<h2 id="2-building-the-library"><a class="header" href="#2-building-the-library">2 Building the Library</a></h2>
<p>Libical uses CMake to generate makefiles. It should build with no adjustments on Linux,
MacOS and Windows using <code>gcc</code>, <code>clang</code> and Microsoft Visual.  Please report build problems
to the <a href="https://github.com/libical/libical/issues">Libical issue tracker</a>.</p>
<p>For a more complete guide to building the library, see the <code>Install.txt</code> file
in the distribution.</p>
<h2 id="3-structure"><a class="header" href="#3-structure">3 Structure</a></h2>
<p>The iCalendar data model is based on four types of objects: <em>components</em>,
<em>properties</em>, <em>values</em> and <em>parameters</em>.</p>
<p>Properties are the fundamental unit of information in iCalendar, and they
work a bit like a hash entry, with a constant key and a variable value.
Properties may also have modifiers, called parameters. In the iCal
content line</p>
<pre><code class="language-ical">ORGANIZER;ROLE=CHAIR:MAILTO:mrbig@host.com
</code></pre>
<p>The property name is <code>ORGANIZER</code>, the value of the property is <code>mrbig@host.com</code>
and the <code>ROLE</code> parameter specifies that Mr Big is the chair of the
meetings associated with this property.</p>
<p>Components are groups of properties that represent the core objects
of a calendar system, such as events or timezones. Components are
delimited by <code>BEGIN</code> and <code>END</code> tags.</p>
<p>When a component is sent across a network, if it is un-encrypted, it
will look something like:</p>
<pre><code class="language-ical">BEGIN:VCALENDAR
METHOD:REQUEST
PRODID: -//hacksw/handcal//NONSGML v1.0//EN
BEGIN:VEVENT
DTSTAMP:19980309T231000Z
UID:guid-1.host1.com
ORGANIZER;ROLE=CHAIR:MAILTO:mrbig@host.com
ATTENDEE;RSVP=TRUE;ROLE=REQ-PARTICIPANT;CUTYPE=GROUP:
  MAILTO:employee-A@host.com
DESCRIPTION:Project XYZ Review Meeting
CATEGORIES:MEETING
CLASS:PUBLIC
CREATED:19980309T130000Z
SUMMARY:XYZ Project Review
DTSTART;TZID=US-Eastern:19980312T083000
DTEND;TZID=US-Eastern:19980312T093000
LOCATION:1CP Conference Room 4350
END:VEVENT
END:VCALENDAR
</code></pre>
<p>Note that components can be nested; this example has both a VCALENDAR
and a VEVENT component, one nested inside the other.</p>
<h3 id="31-core-ical-classes"><a class="header" href="#31-core-ical-classes">3.1 Core iCal classes</a></h3>
<p>Libical is an object-based, data-oriented library. Nearly all of the
routines in the library are associated with an opaque data types and
perform some operation on that data type. Although the library does
not actually have classes, we will use those terms since the behavior
of these associations of data and routines is very similar to a class.</p>
<h4 id="311-properties"><a class="header" href="#311-properties">3.1.1 Properties</a></h4>
<p>Properties are represented with the <code>icalproperty</code> class and its many
"derived" classes with one "derived" class per property type in <a href="https://tools.ietf.org/html/rfc5545">RFC5545</a>.
Again, there is no actual inheritance relations, but there are clusters
of routines that make this term useful. A property is a container
for a single value and a set of parameters.</p>
<h4 id="312-components"><a class="header" href="#312-components">3.1.2 Components</a></h4>
<p>In libical, components are represented with the <code>icalcomponent</code> class.
<code>icalcomponent</code> is a container for a set of other components and properties.</p>
<h4 id="313-values"><a class="header" href="#313-values">3.1.3 Values</a></h4>
<p>Values are represented in a similar way to properties; a base class
and many "derived " classes. A value is essentially an abstract handle
on a single fundamental type, a structure or a union.</p>
<h4 id="314-parameters"><a class="header" href="#314-parameters">3.1.4 Parameters</a></h4>
<p>Parameters are represented in a similar way to properties, except that
they contain only one value.</p>
<h3 id="32-other-elements-of-libical"><a class="header" href="#32-other-elements-of-libical">3.2 Other elements of libical</a></h3>
<p>In addition to the core iCal classes, libical has many other types,
structures, and classes that aid in creating and using iCal components.</p>
<h4 id="321-enumerations-and-types"><a class="header" href="#321-enumerations-and-types">3.2.1 Enumerations and types</a></h4>
<p>Libical is strongly typed, so every component, property, parameter,
and value type has an enumeration, and some have an associated structure
or union.</p>
<h4 id="322-the-parser"><a class="header" href="#322-the-parser">3.2.2 The parser</a></h4>
<p>The libical parser offers a variety of ways to convert <a href="https://tools.ietf.org/html/rfc5545">RFC5545</a> text
into a libical internal component structure. The parser can parse
blocks of text as a string, or it can parse line-by-line.</p>
<h4 id="323-error-objects"><a class="header" href="#323-error-objects">3.2.3 Error objects</a></h4>
<p>Libical has a substantial error reporting system for both programming
errors and component usage errors.</p>
<h4 id="324-memory-management"><a class="header" href="#324-memory-management">3.2.4 Memory Management</a></h4>
<p>Since many of libical's interfaces return strings, the library has its
own memory management system to eliminate the need to free every string
returned from the library.  See <a href="UsingLibical.html#memory">Memory Management</a>.</p>
<h4 id="325-storage-classes"><a class="header" href="#325-storage-classes">3.2.5 Storage classes</a></h4>
<p>The library also offers several classes to store components to files,
memory or databases.</p>
<h2 id="4-differences-from-rfcs"><a class="header" href="#4-differences-from-rfcs">4 Differences From RFCs</a></h2>
<p>Libical has been designed to follow the standards as closely as possible,
so that the key objects in the standards are also key objects in the
library. However, there are a few areas where the specifications are
(arguably) irregular, and following them exactly would result in an
unfriendly interface. These deviations make libical easier to use
by maintaining a self-similar interface.</p>
<h3 id="41-pseudo-components"><a class="header" href="#41-pseudo-components">4.1 Pseudo Components</a></h3>
<p>Libical defines components for groups of properties that look and act
like components, but are not defined as components in the specification.
<code>XDAYLIGHT</code> and <code>XSTANDARD</code> are notable examples. These pseudo components
group properties within the <code>VTIMEZONE</code> components. For instance, the
timezone properties associated with daylight savings time starts with
<code>BEGIN:DAYLIGHT</code> and ends with <code>END:DAYLIGHT</code>, just like other components,
but is not defined as a component in <a href="https://tools.ietf.org/html/rfc5545">RFC5545</a> (see <a href="https://tools.ietf.org/html/rfc5545#section-3.6.5">section 3.6.5</a>)
In libical, this grouping is represented by the <code>XDAYLIGHT</code> component.
Standard iCal components all start with the letter "V," while pseudo
components start with "X."</p>
<p>There are also pseudo components that are conceptually derived classes
of <code>VALARM</code>. <a href="https://tools.ietf.org/html/rfc5546">RFC5546</a> defines what properties may be included in each
component, and for <code>VALARM</code>, the set of properties it may have depends
on the value of the <code>ACTION</code> property.</p>
<p>For instance, if a <code>VALARM</code> component has an <code>ACTION</code> property with the
value of <code>AUDIO</code>, the component must also have an <code>ATTACH</code> property.
However, if the <code>ACTION</code> value is <code>DISPLAY</code>, the component must have
a <code>DESCRIPTION</code> property.</p>
<p>To handle these various, complex restrictions, libical has pseudo components
for each type of alarm: <code>XAUDIOALARM</code>, <code>XDISPLAYALARM</code>, <code>XEMAILALARM</code> and
<code>XPROCEDUREALARM</code>.</p>
<h3 id="42-combined-values"><a class="header" href="#42-combined-values">4.2 Combined Values</a></h3>
<p>Many values can take more than one type. <code>TRIGGER</code>, for instance, can
have a value type of with <code>DURATION</code> or of <code>DATE-TIME</code>. These multiple
types make it difficult to create routines to return the value associated
with a property.</p>
<p>It is natural to have interfaces that would return the value of a property,
but it is cumbersome for a single routine to return multiple types.
So, in libical, properties that can have multiple types are given
a single type that is the union of their RFC5545 types. For instance,
in libical, the value of the <code>TRIGGER</code> property resolves to struct
<code>icaltriggertype</code>. This type is a union of a <code>DURATION</code> and a <code>DATE-TIME</code>.</p>
<h3 id="43-multi-valued-properties"><a class="header" href="#43-multi-valued-properties">4.3 Multi-Valued Properties</a></h3>
<p>Some properties, such as <code>CATEGORIES</code> have only one value type, but each
<code>CATEGORIES</code> property can have multiple value instances. This also results
in a cumbersome interface -- <code>CATEGORIES</code> accessors would have to return
a list while all other accessors returned a single value. In libical,
all properties have a single value, and multi-valued properties are
broken down into multiple single valued properties during parsing.
That is, an input line like,</p>
<pre><code class="language-ical">CATEGORIES: work, home
</code></pre>
<p>becomes in libical's internal representation</p>
<pre><code class="language-ical">CATEGORIES: work
CATEGORIES: home
</code></pre>
<p>Oddly, <a href="https://tools.ietf.org/html/rfc5545">RFC5545</a> allows some multi-valued properties (like <code>FREEBUSY</code>)
to exist as both a multi-values property and as multiple single
value properties, while others (like <code>CATEGORIES</code>) can only exist
as single multi-valued properties. This makes the internal representation
for <code>CATEGORIES</code> illegal.  However when you convert a component to a
string, the library will collect all of the <code>CATEGORIES</code> properties
into one.</p>
<h2 id="5-using-libical"><a class="header" href="#5-using-libical">5 Using libical</a></h2>
<h3 id="51-creating-components"><a class="header" href="#51-creating-components">5.1 Creating Components</a></h3>
<p>There are three ways to create components in Libical:</p>
<ol>
<li>creating individual objects and assembling them,</li>
<li>building entire objects in massive vargs calls,</li>
<li>parsing a text file containing iCalendar data.</li>
</ol>
<h4 id="511-constructor-interfaces"><a class="header" href="#511-constructor-interfaces">5.1.1 Constructor Interfaces</a></h4>
<p>Using constructor interfaces, you create each of the objects separately
and then assemble them in to components:</p>
<pre><code class="language-c">icalcomponent *event;
icalproperty *prop;
icalparameter *param;
struct icaltimetype atime;

// create new VEVENT component
event = icalcomponent_new(ICAL_VEVENT_COMPONENT);

// add DTSTAMP property to the event
prop = icalproperty_new_dtstamp(atime);
icalcomponent_add_property(event, prop);

// add UID property to the event
prop = icalproperty_new_uid("guid-1.example.com");
icalcomponent_add_property(event, prop);

// add ORGANIZER (with ROLE=CHAIR) to the event
prop = icalproperty_new_organizer("mrbig@example.com");
param = icalparameter_new_role(ICAL_ROLE_CHAIR);
icalproperty_add_parameter(prop, param);
icalcomponent_add_property(event, prop);
</code></pre>
<p>Notice that libical uses a semi-object-oriented style of interface.
Most things you work with are objects, that are instantiated with
a constructor that has "new" in the name. Also note that, other than
the object reference, most structure data is passed in to libical
routines by value. Libical has some complex but very regular memory
handling rules. These are detailed in section <a href="UsingLibical.html#memory">Memory Management</a>.</p>
<p>If any of the constructors fail, they will return 0. If you try to
insert 0 into a property or component, or use a zero-valued object
reference, libical will either silently ignore the error or will abort
with an error message. This behavior is controlled by a compile time
flag (<code>ICAL_ERRORS_ARE_FATAL</code>), and will abort by default.</p>
<h4 id="512-varargs-constructors"><a class="header" href="#512-varargs-constructors">5.1.2 varargs Constructors</a></h4>
<p>There is another way to create complex components, which is arguably
more elegant, if you are not horrified by varargs. The varargs constructor
interface allows you to create intricate components in a single block
of code. Here is the previous examples in the vaargs style.</p>
<pre><code class="language-c">icalcomponent *calendar;
struct icaltimetype atime;

calendar =
    icalcomponent_vanew(
        ICAL_VCALENDAR_COMPONENT,
        icalproperty_new_version("2.0"),
        icalproperty_new_prodid(
             "-//RDU Software//NONSGML HandCal//EN"),
        icalcomponent_vanew(
            ICAL_VEVENT_COMPONENT,
            icalproperty_new_dtstamp(atime),
            icalproperty_new_uid("guid-1.host1.com"),
            icalproperty_vanew_organizer(
                "mrbig@host.com",
                icalparameter_new_role(ICAL_ROLE_CHAIR),
                (void *)0),
            icalproperty_vanew_attendee(
                "employee-A@host.com",
                icalparameter_new_role(
                    ICAL_ROLE_REQPARTICIPANT),
                icalparameter_new_rsvp(1),
                icalparameter_new_cutype(ICAL_CUTYPE_GROUP),
                (void *)0),
            icalproperty_new_location(
               "1CP Conference Room 4350"),
            (void *)0),
        (void *)0);
</code></pre>
<p>This form is similar to the constructor form, except that the constructors
have <code>vanew</code> instead of <code>new</code> in the name. The arguments are similar
too, except that the component constructor can have a list of properties,
and the property constructor can have a list of parameters.</p>
<p><em>Be sure to terminate every list with a <code>NULL</code> (or a <em><code>(void 0)</code></em>, or your code
will crash, if you are lucky</em>. The reason you can't use 0 itself is that
depending on what platform you are on, <code>sizeof(int) ≠ sizeof(void *)</code>.</p>
<h4 id="513-parsing-text-files"><a class="header" href="#513-parsing-text-files">5.1.3 Parsing Text Files</a></h4>
<p>The final way to create components will probably be the most common;
you can create components from <a href="https://tools.ietf.org/html/rfc5545">RFC5545</a> compliant text. If you have
the string in memory, use</p>
<pre><code class="language-c">icalcomponent* icalparser_parse_string(char* str);
</code></pre>
<p>If the string contains only one component, the parser will return the
component in libical form. If the string contains multiple components,
the multiple components will be returned as the children of an
<code>ICAL_XROOT_COMPONENT</code> component.</p>
<p>Parsing a whole string may seem wasteful if you want to pull a large
component off of the network or from a file; you may prefer to parse
the component line by line. This is possible too by using:</p>
<pre><code class="language-c">icalparser* icalparser_new();

void icalparser_free(
    icalparser* parser);

icalparser_get_line(
    icalparser *parser,
    char* (*read_stream)(char *s, size_t size,  void *d));

icalparser_add_line(
    icalparser *parser,
    char *line);

icalparser_set_gen_data(
    icalparser *parser,
    void *data);
</code></pre>
<p>These routines will construct a parser object to which you can add
lines of input and retrieve any components that the parser creates
from the input. These routines work by specifying an adaptor routine
to get string data from a source. For example:</p>
<pre><code class="language-c">char* read_stream(char *s, size_t size, void *d)
{
    return fgets(s, size, (FILE*)d);
}

int main(int argc, char *argv[])
{
    char *line;
    icalcomponent *component;
    icalparser *parser = icalparser_new();

    // open file (first command-line argument)
    FILE* stream = fopen(argv[1], "r");

    // associate the FILE with the parser so that read_stream
    // will have access to it
    icalparser_set_gen_data(parser, stream);

    do {
        // read the file, line-by-line, and parse the data
        line = icalparser_get_line(parser, read_stream);
        component = icalparser_add_line(parser, line);

        // if icalparser has finished parsing a component,
        // it will return it
        if (component != 0) {
            // print the parsed component
            printf("%s", icalcomponent_as_ical_string(component));
            icalparser_clean(parser);

            printf("\n---------------\n");

            icalcomponent_free(component);
        }
    } while (line != 0);

    return 0;
}
</code></pre>
<p>The parser object parametrizes the routine used to get input lines
with <code>icalparser_set_gen_data()</code>and <code>icalparser_get_line()</code>. In this
example, the routine <code>read_stream()</code> will fetch the next line from a
stream, with the stream passed in as the <code>void*</code> parameter d. The parser
calls <code>read_stream()</code> from <code>icalparser_get_line()</code>, but it also needs
to know what stream to use. This is set by the call to <code>icalparser_set_gen_data()</code>.
By using a different routine for <code>read_stream()</code> or passing in different
data with <code>icalparser_set_gen_data()</code>, you can connect to any data source.</p>
<p>Using the same mechanism, other implementations could read from memory
buffers, sockets or other interfaces.</p>
<p>Since the example code is a very common way to use the parser, there
is a convenience routine;</p>
<pre><code class="language-c">icalcomponent* icalparser_parse(
    icalparser *parser,
    char* (*line_gen_func)(char *s, size_t size,  void *d));
</code></pre>
<p>To use this routine, you still must construct the parser object and
pass in a reference to a line reading routine. If the parser can create
a single component from the input, it will return a pointer to the
newly constructed component. If the parser can construct multiple
components from the input, it will return a reference to an <code>XROOT</code>
component (of type <code>ICAL_XROOT_COMPONENT</code>.) This <code>XROOT</code> component will
hold all of the components constructed from the input as children.</p>
<pre><code class="language-c">char* read_stream(char *s, size_t size, void *d)
{
    return fgets(s, size, (FILE*)d);
}

int main(int argc, char *argv[])
{
    char* line;
    icalcomponent *component;
    icalparser *parser = icalparser_new();

    // open file (first command-line argument)
    FILE* stream = fopen(argv[1], "r");

    // associate the FILE with the parser so that read_stream
    // will have access to it
    icalparser_set_gen_data(parser, stream);

    // parse the opened file
    component = icalparser_parse(parser, read_stream);

    if (component != 0) {
        // print the parsed component
        printf("%s", icalcomponent_as_ical_string(component));
        icalcomponent_free(component);
    }

    icalparser_free(parser);

    return 0;
}
</code></pre>
<h3 id="52-accessing-components"><a class="header" href="#52-accessing-components">5.2 Accessing Components</a></h3>
<p>Given a reference to a component, you probably will want to access
the properties, parameters and values inside. Libical interfaces let
you find sub-component, add and remove sub-components, and do the
same three operations on properties.</p>
<h4 id="521-finding-components"><a class="header" href="#521-finding-components">5.2.1 Finding Components</a></h4>
<p>To find a sub-component of a component, use:</p>
<pre><code class="language-c">icalcomponent* icalcomponent_get_first_component(
    icalcomponent* component,
    icalcomponent_kind kind);
</code></pre>
<p>This routine will return a reference to the first component of the
type <code>kind</code>. The key kind values, listed in icalenums.h are:</p>
<ul>
<li><code>ICAL_ANY_COMPONENT</code></li>
<li><code>ICAL_VEVENT_COMPONENT</code></li>
<li><code>ICAL_VTODO_COMPONENT</code></li>
<li><code>ICAL_VJOURNAL_COMPONENT</code></li>
<li><code>ICAL_VCALENDAR_COMPONENT</code></li>
<li><code>ICAL_VFREEBUSY_COMPONENT</code></li>
<li><code>ICAL_VALARM_COMPONENT</code></li>
</ul>
<p>These are only the most common components; there are many more listed
in icalenums.h.</p>
<p>As you might guess, if there is more than one subcomponent of the type
you have chosen, this routine will return only the first. to get at
the others, you need to iterate through the component.</p>
<h4 id="522-iterating-through-components"><a class="header" href="#522-iterating-through-components">5.2.2 Iterating Through Components</a></h4>
<p>Iteration requires a second routine to get the next subcomponent after
the first:</p>
<pre><code class="language-c">icalcomponent* icalcomponent_get_next_component(
    icalcomponent* component,
    icalcomponent_kind kind);
</code></pre>
<p>With the 'first' and 'next' routines, you can create a for loop to
iterate through all of a components subcomponents</p>
<pre><code class="language-c">icalcomponent *c;

for(c = icalcomponent_get_first_component(comp, ICAL_ANY_COMPONENT);
    c != 0;
    c = icalcomponent_get_next_component(comp, ICAL_ANY_COMPONENT))
{
      do_something(c);
}
</code></pre>
<p>This code bit will iterate through all of the subcomponents in <code>comp</code>
but you can select a specific type of component by changing <code>ICAL_ANY_COMPONENT</code>
to another component type.</p>
<h4 id="523-using-component-iterators"><a class="header" href="#523-using-component-iterators">5.2.3 Using Component Iterators</a></h4>
<p>The iteration model in the previous section requires the component
to keep the state of the iteration. So, you could not use this model
to perform a sorting operations, since you'd need two iterators and
there is only space for one. If you ever call <code>icalcomponent_get_first_component()</code>
when an iteration is in progress, the pointer will be reset to the
beginning.</p>
<p>To solve this problem, there are also external iterators for components.
The routines associated with these external iterators are:</p>
<pre><code class="language-c">icalcompiter icalcomponent_begin_component(
    icalcomponent* component,
    icalcomponent_kind kind);

icalcompiter icalcomponent_end_component(
    icalcomponent* component,
    icalcomponent_kind kind);

icalcomponent* icalcompiter_next(
    icalcompiter* i);

icalcomponent* icalcompiter_prior(
    icalcompiter* i);

icalcomponent* icalcompiter_deref(
    icalcompiter* i);
</code></pre>
<p>The <code>*_begin_*()</code> and <code>*_end_*()</code> routines return a new iterator that points
to the beginning and end of the list of subcomponent for the given
component, and the kind argument works like the kind argument for
internal iterators.</p>
<p>After creating an iterators, use <code>*_next()</code> and <code>*_prior()</code> to step forward
and backward through the list and get the component that the iterator
points to, and use <code>_deref()</code> to return the component that the iterator
points to without moving the iterator. All routines will return 0
when they move to point off the end of the list.</p>
<p>Here is an example of a loop using these routines:</p>
<pre><code class="language-c">for(i = icalcomponent_begin_component(impl-&gt;cluster, ICAL_ANY_COMPONENT);
    icalcompiter_deref(&amp;i)!= 0;
    icalcompiter_next(&amp;i))
{
    icalcomponent *this = icalcompiter_deref(&amp;i);
}
</code></pre>
<h4 id="524-removing-components"><a class="header" href="#524-removing-components">5.2.4 Removing Components</a></h4>
<p>Removing an element from a list while iterating through the list with
the internal iterators can cause problems, since you will probably
be removing the element that the internal iterator points to. The
<code>_remove()</code> routine will keep the iterator valid by moving it to the
next component, but in a normal loop, this will result in two advances
per iteration, and you will remove only every other component.  To
avoid the problem, you will need to step the iterator ahead of the
element you are going to remove, like this:</p>
<pre><code class="language-c">for(c = icalcomponent_get_first_component(parent_comp, ICAL_ANY_COMPONENT);
    c != 0;
    c = next)
{
    next = icalcomponent_get_next_component(parent_comp, ICAL_ANY_COMPONENT);
    icalcomponent_remove_component(parent_comp,c);
}
</code></pre>
<p>Another way to remove components is to rely on the side effect of
<code>icalcomponent_remove_component()</code>:
if component iterator in the parent component is pointing to the child
that will be removed, it will move the iterator to the component after
the child. The following code will exploit this behavior:</p>
<pre><code class="language-c">icalcomponent_get_first_component(parent_comp,ICAL_VEVENT_COMPONENT);

while((c=icalcomponent_get_current_component(c)) != 0){
   if(icalcomponent_isa(c) == ICAL_VEVENT_COMPONENT){
      icalcomponent_remove_component(parent_comp,inner);
   } else {
      icalcomponent_get_next_component(parent_comp,ICAL_VEVENT_COMPONENT);
   }
}
</code></pre>
<h4 id="525-working-with-properties-and-parameters"><a class="header" href="#525-working-with-properties-and-parameters">5.2.5 Working with properties and parameters</a></h4>
<p>Finding, iterating and removing properties works the same as it does
for components, using the property-specific or parameter-specific
interfaces:</p>
<pre><code class="language-c">icalproperty* icalcomponent_get_first_property(
    icalcomponent* component,
    icalproperty_kind kind);

icalproperty* icalcomponent_get_next_property(
    icalcomponent* component,
    icalproperty_kind kind);

void icalcomponent_add_property(
    icalcomponent* component,
    icalproperty* property);

void icalcomponent_remove_property(
    icalcomponent* component,
    icalproperty* property);
</code></pre>
<p>For parameters:</p>
<pre><code class="language-c">icalparameter* icalproperty_get_first_parameter(
     icalproperty* prop,
     icalparameter_kind kind);

icalparameter* icalproperty_get_next_parameter(
     icalproperty* prop,
     icalparameter_kind kind);

void icalproperty_add_parameter(
     icalproperty* prop,
     icalparameter* parameter);

void icalproperty_remove_parameter_by_kind(
     icalproperty* prop,
     icalparameter_kind kind);
</code></pre>
<p>Note that since there should be only one parameter of each type in
a property, you will rarely need to use <code>icalparameter_get_next_parameter()</code>.</p>
<h4 id="526-working-with-values"><a class="header" href="#526-working-with-values">5.2.6 Working with values</a></h4>
<p>Values are typically part of a property, although they can exist on
their own. You can manipulate them either as part of the property
or independently.</p>
<p>The most common way to work with values to is to manipulate them from
the properties that contain them. This involves fewer routine calls
and intermediate variables than working with them independently, and
it is type-safe.</p>
<p>For each property, there are a <code>_get_()</code> and a <code>_set_()</code> routine that
accesses the internal value. For instanace, for the <code>UID</code> property, the
routines are:</p>
<pre><code class="language-c">void icalproperty_set_uid(
    icalproperty* prop,
    const char* v);

const char* icalproperty_get_uid(
    icalproperty* prop);
</code></pre>
<p>For multi-valued properties, like <code>ATTACH</code>, the value type is usually
a struct or union that holds both possible types.</p>
<p>If you want to work with the underlying value object, you can get and
set it with:</p>
<pre><code class="language-c">icalvalue* icalproperty_get_value(
    icalproperty* prop);

void icalproperty_set_value(
    icalproperty* prop,
    icalvalue* value);
</code></pre>
<p><code>icalproperty_get_value()</code> will return a reference that you can manipulate
with other icalvalue routines. Most of the time, you will have to
know what the type of the value is. For instance, if you know that
the value is a <code>DATETIME</code> type, you can manipulate it with:</p>
<pre><code class="language-c">struct icaltimetype icalvalue_get_datetime(
    icalvalue* value);

void icalvalue_set_datetime(
    icalvalue* value,
    struct icaltimetype v);
</code></pre>
<p>Some complex value types, such as <code>ATTACH</code> and <code>RECUR</code>, are passed by reference
rather than by value. For example, when using <code>icalvalue_get_recur()</code>, you
receive a reference to the internal state of the value object. Conversely, when
setting these values, the value object retains a reference to the original
object instead of creating a copy.</p>
<p><strong>Caution:</strong> Manipulating this referenced object will also modify the owning
value object.</p>
<p>Be mindful of the memory management for these objects, which is managed through
reference counting. For more details, see <a href="UsingLibical.html#memory">Memory Management</a>.</p>
<p>When working with an extension property or value (and <code>X-PROPERTY</code> or
a property that has the parameter <code>VALUE=x-name</code>), the value type is
always a string. To get and set the value, use:</p>
<pre><code class="language-x">void icalproperty_set_x(
    icalproperty* prop,
    char* v);

char* icalproperty_get_x(
    icalproperty* prop);
</code></pre>
<p>All X properties have the type of <code>ICAL_X_PROPERTY</code>, so you will need
these routines to get and set the name of the property:</p>
<pre><code class="language-c">char* icalproperty_get_x_name(
    icalproperty* prop)

void icalproperty_set_x_name(
    icalproperty* prop,
    char* name);
</code></pre>
<h4 id="527-checking-component-validity"><a class="header" href="#527-checking-component-validity">5.2.7 Checking Component Validity</a></h4>
<p><a href="https://tools.ietf.org/html/rfc5546">RFC5546</a> defines rules for what properties must exist in a component
to be used for transferring scheduling data. Most of these rules relate
to the existence of properties relative to the <code>METHOD</code> property, which
declares what operation a remote receiver should use to process a
component. For instance, if the <code>METHOD</code> is <code>REQUEST</code> and the component
is a <code>VEVENT</code>, the sender is probably asking the receiver to join in
a meeting. In this case, RFC5546 says that the component must specify
a start time (<code>DTSTART</code>) and list the receiver as an attendee
(<code>ATTENDEE</code>).</p>
<p>Libical can check these restrictions with the routine:</p>
<pre><code class="language-c">int icalrestriction_check(icalcomponent* comp);
</code></pre>
<p>This routine returns 0 if the component does not pass RFC5546 restrictions,
or if the component is malformed. The component you pass in must be
a <code>VCALENDAR</code>, with one or more children, like the examples in RFC5546.</p>
<p>When this routine runs, it will insert new properties into the component
to indicate any errors it finds. See section 6.5.3, <code>X-LIC-ERROR</code> for
more information about these error properties.</p>
<p>5.2.8 Converting Components to Text</p>
<p>To create an RFC5545 compliant text representation of an object, use
one of the <code>*_as_ical_string()</code> routines:</p>
<pre><code class="language-c">char* icalcomponent_as_ical_string(icalcomponent* component)

char* icalproperty_as_ical_string(icalproperty* property)

char* icalparameter_as_ical_string(icalparameter* parameter)

char* icalvalue_as_ical_string(icalvalue* value)
</code></pre>
<p>In most cases, you will only use <code>icalcomponent_as_ical_string()</code>, since
it will cascade and convert all of the parameters, properties and
values that are attached to the root component.</p>
<p>Remember that the string returned by these routines is owned by the
library, and will eventually be re-written. You should copy it if
you want to preserve it.</p>
<h3 id="53-time"><a class="header" href="#53-time">5.3 Time</a></h3>
<h4 id="531-time-structure"><a class="header" href="#531-time-structure">5.3.1 Time structure</a></h4>
<p>Libical defines its own time structure for storing all dates and times.
It would have been nice to reuse the C library's struct <code>tm</code>, but that
structure does not differentiate between dates and times, and between
local time and UTC. The libical structure is:</p>
<pre><code class="language-c">struct icaltimetype {
  int year;
  int month;
  int day;
  int hour;
  int minute;
  int second;
  int is_utc; /* 1-&gt; time is in UTC timezone */
  int is_date; /* 1 -&gt; interpret this as date. */
};
</code></pre>
<p>The <code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code>, <code>minute</code> and <code>second</code> fields
hold the broken-out
time values. The <code>is_utc</code> field distinguishes between times in UTC and
a local time zone. The <code>is_date</code> field indicates if the time should
be interpreted only as a date. If it is a date, the hour, minute and
second fields are assumed to be zero, regardless of their actual values.</p>
<h4 id="532-creating-time-structures"><a class="header" href="#532-creating-time-structures">5.3.2 Creating time structures</a></h4>
<p>There are several ways to create a new icaltimetype structure:</p>
<pre><code class="language-c">struct icaltimetype icaltime_from_string(
    const char* str);

struct icaltimetype icaltime_from_timet_with_zone(
    icaltime_t v,
    int is_date,
    icaltimezone* zone);
</code></pre>
<p><code>icaltime_from_string()</code> takes any RFC5545 compliant time string:</p>
<pre><code class="language-c">struct icaltimetype tt = icaltime_from_string("19970101T103000");
</code></pre>
<p><code>icaltime_from_timet_with_zone()</code> takes a <code>icaltime_t</code> value, representing seconds past
the POSIX epoch, a flag to indicate if the time is a date, and a time zone.
Dates have an identical structure to a time, but the time portion (hours,
minutes and seconds) is always 00:00:00. Dates act differently in
sorting and comparison, and they have a different string representation
in <a href="https://tools.ietf.org/html/rfc5545">RFC5545</a>.</p>
<h4 id="533-time-manipulating-routines"><a class="header" href="#533-time-manipulating-routines">5.3.3 Time manipulating routines</a></h4>
<p>The <code>null</code> time value is used to indicate that the data in the structure
is not a valid time.</p>
<pre><code class="language-c">struct icaltimetype icaltime_null_time(void);

int icaltime_is_null_time(struct icaltimetype t);
</code></pre>
<p>It is sensible for the broken-out time fields to contain values that
are not permitted in an ISO compliant time string. For instance, the
seconds field can hold values greater than 59, and the hours field
can hold values larger than 24. The excessive values will be rolled
over into the next larger field when the structure is normalized.</p>
<pre><code class="language-c">struct icaltimetype icaltime_normalize(struct icaltimetype t);
</code></pre>
<p>Normalizing allows you to do arithmetic operations on time values.</p>
<pre><code class="language-c">struct icaltimetype tt = icaltime_from_string("19970101T103000");

tt.days +=3
tt.second += 70;

tt = icaltime_normalize(tt);
</code></pre>
<p>There are several routines to get the day of the week or month, etc,
from a time structure.</p>
<pre><code class="language-c">short icaltime_day_of_year(
    struct icaltimetype t);

struct icaltimetype icaltime_from_day_of_year(
    short doy,
    short year);

short icaltime_day_of_week(
    struct icaltimetype t);

short icaltime_start_doy_week(
    struct icaltimetype t,
    int fdow);

short icaltime_week_number(
    short day_of_month,
    short month,
    short year);

short icaltime_days_in_month(
    short month,
    short year);
</code></pre>
<p>Two routines convert time structures to and from the number of seconds
since the POSIX epoch. The <code>is_date</code> field indicates whether or not
the hour, minute and second fields should be used in the conversion.</p>
<pre><code class="language-c">struct icaltimetype icaltime_from_timet_with_zone(
    icaltime_t v,
    int is_date,
    icaltimezone* zone);

icaltime_t icaltime_as_timet(
    struct icaltimetype);
</code></pre>
<p>The compare routine works exactly like <code>strcmp()</code>, but on time structures.</p>
<pre><code class="language-c">int icaltime_compare(
    struct icaltimetype a,
    struct icaltimetype b);
</code></pre>
<p>The following routines convert between UTC and a named timezone. The
tzid field must be a timezone name from the Olsen database, such as
<code>America/Los_Angeles</code>.</p>
<p>The <code>utc_offset</code> routine returns the offset of the named time zone from
UTC, in seconds.</p>
<p>The <code>tt</code> parameter in the following routines indicates the date on which
the conversion should be made. The parameter is necessary because
timezones have many different rules for when daylight savings time
is used, and these rules can change over time. So, for a single timezone
one year may have daylight savings time on March 15, but for other
years March 15 may be standard time, and some years may have standard
time all year.</p>
<pre><code class="language-c">int icaltime_utc_offset(
    struct icaltimetype tt,
    char* tzid);

int icaltime_local_utc_offset();

struct icaltimetype icaltime_as_utc(
    struct icaltimetype tt,
    char* tzid);

struct icaltimetype icaltime_as_zone(
    struct icaltimetype tt,
    char* tzid);

struct icaltimetype icaltime_as_local(
    struct icaltimetype tt);
</code></pre>
<h3 id="54-storing-objects"><a class="header" href="#54-storing-objects">5.4 Storing Objects</a></h3>
<p>The libical distribution includes a separate library, libicalss, that
allows you to store iCal component data to disk in a variety of ways.</p>
<p>The file storage routines are organized in an inheritance hierarchy
that is rooted in icalset, with the derived class icalfileset and
icaldirset. Icalfileset stores components to a file, while icaldirset
stores components to multiple files, one per month based on DTSTAMP.
Other storages classes, for storage to a heap or a mysql database
for example, could be added in the future.</p>
<p>All of the icalset derived classes have the same interface:</p>
<pre><code class="language-c">icaldirset* icaldirset_new(
    const char* path);

void icaldirset_free(
    icaldirset* store);

const char* icaldirset_path(
    icaldirset* store);

void icaldirset_mark(
    icaldirset* store);

icalerrorenum icaldirset_commit(
    icaldirset* store);

icalerrorenum icaldirset_add_component(
    icaldirset* store,
    icalcomponent* comp);

icalerrorenum icaldirset_remove_component(
    icaldirset* store,
    icalcomponent* comp);

int icaldirset_count_components(
    icaldirset* store,
    icalcomponent_kind kind);

icalerrorenum icaldirset_select(
    icaldirset* store,
    icalcomponent* gauge);

void icaldirset_clear(
    icaldirset* store);

icalcomponent* icaldirset_fetch(
    icaldirset* store,
    const char* uid);

int icaldirset_has_uid(
    icaldirset* store,
    const char* uid);

icalcomponent* icaldirset_fetch_match(
    icaldirset* set,
    icalcomponent *c);

icalerrorenum icaldirset_modify(
    icaldirset* store,
    icalcomponent *oldc,
    icalcomponent *newc);

icalcomponent* icaldirset_get_current_component(
    icaldirset* store);

icalcomponent* icaldirset_get_first_component(
    icaldirset* store);

icalcomponent* icaldirset_get_next_component(
    icaldirset* store);
</code></pre>
<h4 id="541-creating-a-new-set"><a class="header" href="#541-creating-a-new-set">5.4.1 Creating a new set</a></h4>
<p>You can create a new set from either the base class or the direved
class. From the base class use one of:</p>
<pre><code class="language-c">icalset* icalset_new_file(const char* path);

icalset* icalset_new_dir(const char* path);

icalset* icalset_new_heap(void);

icalset* icalset_new_mysql(const char* path);
</code></pre>
<p>You can also create a new set based on the derived class, For instance,
with icalfileset:</p>
<pre><code class="language-c">icalfileset* icalfileset_new(
    const char* path);

icalfileset* icalfileset_new_open(
    const char* path,
    int flags,
    int mode);
</code></pre>
<p><code>icalset_new_file()</code> is identical to <code>icalfileset_new()</code>. Both routines will
open an existing file for reading and writing, or create a new file
if it does not exist. <code>icalfileset_new_open()</code> takes the same arguments
as the open() system routine and behaves in the same way.</p>
<p>The icalset and icalfileset objects are somewhat interchangeable -- you
can use an <code>icalfileset*</code> as an argument to any of the icalset routines.</p>
<p>The following examples will all use icalfileset routines; using the
other icalset derived classes will be similar.</p>
<h4 id="542-adding-finding-and-removing-components"><a class="header" href="#542-adding-finding-and-removing-components">5.4.2 Adding, Finding and Removing Components</a></h4>
<p>To add components to a set, use:</p>
<pre><code class="language-c">icalerrorenum icalfileset_add_component(
    icalfileset* cluster,
    icalcomponent* child);
</code></pre>
<p>The fileset keeps an in-memory copy of the components, and this set
must be written back to the file occasionally. There are two routines
to manage this:</p>
<pre><code class="language-c">void icalfileset_mark(icalfileset* cluster);

icalerrorenum icalfileset_commit(icalfileset* cluster);
</code></pre>
<p><code>icalfileset_mark()</code> indicates that the in-memory components have changed.
Calling the <code>_add_component()</code> routine will call <code>_mark()</code> automatically,
but you may need to call it yourself if you have made a change to
an existing component. The <code>_commit()</code> routine writes the data base to
disk, but only if it is marked. The <code>_commit()</code> routine is called automatically
when the icalfileset is freed.</p>
<p>To iterate through the components in a set, use:</p>
<pre><code class="language-c">icalcomponent* icalfileset_get_first_component(icalfileset* cluster);

icalcomponent* icalfileset_get_next_component(icalfileset* cluster);

icalcomponent* icalfileset_get_current_component (icalfileset* cluster);
</code></pre>
<p>These routines work like the corresponding routines from icalcomponent,
except that their output is filtered through a gauge. A gauge is a
test for the properties within a components; only components that
pass the test are returned. A gauge can be constructed from a MINSQL
string with:</p>
<pre><code class="language-c">icalgauge* icalgauge_new_from_sql(const char* sql);
</code></pre>
<p>Then, you can add the gauge to the set with :</p>
<pre><code class="language-c">icalerrorenum icalfileset_select(
    icalfileset* store,
    icalgauge* gauge);
</code></pre>
<p>Here is an example that puts all of these routines together:</p>
<pre><code class="language-c">void test_fileset()
{
    icalfileset *fs;
    icalcomponent *c;
    int i;
    char *path = "test_fileset.ics";

    icalgauge  *g = icalgauge_new_from_sql(
        "SELECT * FROM VEVENT WHERE DTSTART &gt; '20000103T120000Z' AND
DTSTART &lt;= '20000106T120000Z'");

    fs = icalfileset_new(path);

    for (i = 0; i!= 10; i++){
        c = make_component(i); /* Make a new component where DTSTART has month of i */
        icalfileset_add_component(fs,c);
    }

    icalfileset_commit(fs); /* Write to disk */
    icalfileset_select(fs,g); /* Set the gauge to filter components */

    for (c = icalfileset_get_first_component(fs);
         c != 0;
         c = icalfileset_get_next_component(fs))
    {
        struct icaltimetype t = icalcomponent_get_dtstart(c);
        printf("%s\n",icaltime_as_ctime(t));

    }

    icalfileset_free(fs);
}
</code></pre>
<h4 id="543-other-routines"><a class="header" href="#543-other-routines">5.4.3 Other routines</a></h4>
<p>There are several other routines in the icalset interface, but they
not fully implemented yet.</p>
<h4 id="55-memory-management"><a class="header" href="#55-memory-management">5.5 Memory Management</a></h4>
<p><a id="memory"></a>
Libical relies heavily on dynamic allocation for both the core objects
and for the strings used to hold values. Some of this memory the library
caller owns and must free, and some of the memory is managed by the
library. Here is a summary of the memory rules.</p>
<ol>
<li>
<p>If the function name has "new" in it (such as <code>icalcomponent_new()</code>,
or <code>icalproperty_new_from_string()</code>), the caller gets control
of the memory. The caller also gets control over an object that is
cloned via a function that ends with "_clone" (like <code>icalcomponent_clone()</code>)</p>
</li>
<li>
<p>If you got the memory from a routine with "clone" or "new" in it, you
must call the corresponding <code>*_free()</code> routine to free the memory,
for example use <code>icalcomponent_free()</code> to free objects created with
<code>icalcomponent_new()</code> or <code>icalcomponent_clone()</code>. The only exception
to this rule are objects that implement reference counting (i.e.
<code>icalattach</code> and <code>icalrecurrencetype</code>), which are deallocated via
<code>*_unref()</code> functions. Learn more in the next section.</p>
</li>
<li>
<p>If the function name has "add" in it, the caller is transferring
control of the memory to the routine, for example the function
<code>icalproperty_add_parameter()</code></p>
</li>
<li>
<p>If the function name has "remove" in it, the caller passes in
a pointer to an object and after the call returns, the caller owns
the object. So, before you call <code>icalcomponent_remove_property(comp, foo)</code>,
you do not own "foo" and after the call returns, you do.</p>
</li>
<li>
<p>If the routine returns a string and its name does NOT end in <code>_r</code>,
libical owns the memory and will put it on a ring buffer to reclaim
later. For example, <code>icalcomponent_as_ical_string()</code>. You better
<code>strdup()</code> it if you want to keep it, and you don't have to delete it.</p>
</li>
<li>
<p>If the routine returns a string and its name <em>does</em> end in <code>_r</code>, the
caller gets control of the memory and is responsible for freeing it.
For example, <code>icalcomponent_as_ical_string_r()</code> does the same thing as
<code>icalcomponent_as_ical_string()</code>, except you now have control of the
string buffer it returns.</p>
</li>
</ol>
<h4 id="551-reference-counting"><a class="header" href="#551-reference-counting">5.5.1 Reference Counting</a></h4>
<p>Some special types are managed using reference counting, in particular:</p>
<ul>
<li><code>icalattach</code></li>
<li><code>struct icalrecurrencetype</code></li>
</ul>
<p>Just as any other object they are allocated using any of the <code>*_new*()</code> functions, e.g.</p>
<ul>
<li><code>icalrecurrencetype_new_from_string()</code></li>
<li><code>icalattach_new_from_data()</code></li>
</ul>
<p>When an object is returned by one of these constructor functions, its reference counter is set to 1.</p>
<p>The reference counter can be modified using:</p>
<ul>
<li><code>*_ref()</code> – to increase the counter.</li>
<li><code>*_unref()</code> – to decrease the counter.</li>
</ul>
<p>The object is automatically deallocated when the reference counter reaches 0.
No explicit <code>*_free()</code> functions exist for these types.</p>
<p>When such objects are passed to functions as arguments, it is the task of the function being called
to manage the reference counter, not of the caller. If a pointer to an object is returned by a
function other than the constructor functions, it is the task of the calling function rather than
of the returning function to manage the reference counter.</p>
<h3 id="56-error-handling"><a class="header" href="#56-error-handling">5.6 Error Handling</a></h3>
<p>Libical has several error handling mechanisms for the various types
of programming, semantic and syntactic errors you may encounter.</p>
<h4 id="561-return-values"><a class="header" href="#561-return-values">5.6.1 Return values</a></h4>
<p>Many library routines signal errors through their return values. All
routines that return a pointer, such as <code>icalcomponent_new()</code>, will
return 0 (zero) on a fatal error. Some routines will return a value
of enum <code>icalerrorenum</code>.</p>
<p>5.6.2 <code>icalerrno</code></p>
<p>Most routines will set the global error value <code>icalerrno</code> on errors.
This variable is an enumeration; permissible values can be found in
<code>libical/icalerror.h</code>. If the routine returns an enum icalerrorenum,
then the return value will be the same as icalerrno. You can use
<code>icalerror_strerror()</code> to get a string that describes the error.
The enumerations are:</p>
<ul>
<li>
<p><code>ICAL_BADARG_ERROR</code>: One of the arguments to a routine was bad.
Typically for a null pointer.</p>
</li>
<li>
<p><code>ICAL_NEWFAILED_ERROR</code>: A <code>new()</code> or <code>malloc()</code> failed.</p>
</li>
<li>
<p><code>ICAL_MALFORMEDDATA_ERROR</code>: An input string was not in the correct format</p>
</li>
<li>
<p><code>ICAL_PARSE_ERROR</code>: The parser failed to parse an incoming component</p>
</li>
<li>
<p><code>ICAL_INTERNAL_ERROR</code>: Largely equivalent to an assert</p>
</li>
<li>
<p><code>ICAL_FILE_ERROR</code>: A file operation failed. Check errno for more detail.</p>
</li>
<li>
<p><code>ICAL_ALLOCATION_ERROR</code>: ?</p>
</li>
<li>
<p><code>ICAL_USAGE_ERROR</code>: ?</p>
</li>
<li>
<p><code>ICAL_NO_ERROR</code>: No error</p>
</li>
<li>
<p><code>ICAL_MULTIPLEINCLUSION_ERROR</code>: ?</p>
</li>
<li>
<p><code>ICAL_TIMEDOUT_ERROR</code>: For CSTP and acquiring locks</p>
</li>
<li>
<p><code>ICAL_UNKNOWN_ERROR</code>: ?</p>
</li>
</ul>
<h4 id="563-x-lic-error-and-x-lic-invalid-component"><a class="header" href="#563-x-lic-error-and-x-lic-invalid-component">5.6.3 <code>X-LIC-ERROR</code> and <code>X-LIC-INVALID-COMPONENT</code></a></h4>
<p>The library handles semantic and syntactic errors in components by
inserting errors properties into the components. If the parser cannot
parse incoming text (a syntactic error) or if the <code>icalrestriction_check()</code>
routine indicates that the component does not meet the requirements
of RFC5546 (a semantic error) the library will insert properties
of the type <code>X-LIC-ERROR</code> to describe the error. Here is an example
of the error property:</p>
<pre><code class="language-ical">X-LIC-ERROR;X-LIC-ERRORTYPE=INVALID_ITIP :Failed iTIP restrictions
for property DTSTART.

Expected 1 instances of the property and got 0
</code></pre>
<p>This error resulted from a call to <code>icalrestriction_check()</code>, which discovered
that the component does not have a <code>DTSTART</code> property, as required by
RFC5545.</p>
<p>There are a few routines to manipulate error properties:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Routine</th><th style="text-align: left">Purpose</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>void icalrestriction_check()</code></td><td style="text-align: left">Check a component against RFC5546 and insert error properties to indicate non compliance</td></tr>
<tr><td style="text-align: left"><code>int icalcomponent_count_errors()</code></td><td style="text-align: left">Return the number of error properties in a component</td></tr>
<tr><td style="text-align: left"><code>void icalcomponent_strip_errors()</code></td><td style="text-align: left">Remove all error properties in a component</td></tr>
<tr><td style="text-align: left"><code>void icalcomponent_convert_errors()</code></td><td style="text-align: left">Convert some error properties into REQUESTS-STATUS properties to indicate the inability to process the component as an iTIP request</td></tr>
</tbody></table>
</div>
<p>The types of errors are listed in icalerror.h. They are:</p>
<ul>
<li><code>ICAL_XLICERRORTYPE_COMPONENTPARSEERROR</code></li>
<li><code>ICAL_XLICERRORTYPE_PARAMETERVALUEPARSEERROR</code></li>
<li><code>ICAL_XLICERRORTYPE_PARAMETERNAMEPARSEERROR</code></li>
<li><code>ICAL_XLICERRORTYPE_PROPERTYPARSEERROR</code></li>
<li><code>ICAL_XLICERRORTYPE_VALUEPARSEERROR</code></li>
<li><code>ICAL_XLICERRORTYPE_UNKVCALPROP</code></li>
<li><code>ICAL_XLICERRORTYPE_INVALIDITIP</code></li>
</ul>
<p>The libical parser will generate the error that end in <code>PARSEERROR</code> when
it encounters garbage in the input steam. <code>ICAL_XLICERRORTYPE_INVALIDITIP</code>
is inserted by <code>icalrestriction_check()</code>, and <code>ICAL_XLICERRORTYPE_UNKVCALPROP</code>
is generated by <code>icalvcal_convert()</code> when it encounters a vCal property
that it cannot convert or does not know about.</p>
<p><code>icalcomponent_convert_errors()</code> converts some of the error properties
in a component into <code>REQUEST-STATUS</code> properties that indicate a failure.
As of libical version 0.18, this routine only converts <code>PARSEERROR</code> errors
and it always generates a 3.x (failure) code. This makes it more
of a good idea than a really useful bit of code.</p>
<h4 id="564-ical_errors_are_fatal-and-icalerror_errors_are_fatal"><a class="header" href="#564-ical_errors_are_fatal-and-icalerror_errors_are_fatal">5.6.4 <code>ICAL_ERRORS_ARE_FATAL</code> and <code>icalerror_errors_are_fatal</code></a></h4>
<p>If <code>icalerror_get_errors_are_fatal()</code> returns 1, then any error
condition will cause the program to abort. The abort occurs
in <code>icalerror_set_errno()</code>, and is done with an assert(0) if NDEBUG
is undefined, and with <code>icalerror_crash_here()</code> if NDEBUG is defined.
Initially, <code>icalerror_get_errors_are_fatal()</code> is 1 when <code>ICAL_ERRORS_ARE_FATAL</code>
is defined, and 0 otherwise. Since <code>ICAL_ERRORS_ARE_FATAL</code> is defined
by default, <code>icalerror_get_errors_are_fatal()</code> is also set to 1 by default.</p>
<p>You can change the compiled-in <code>ICAL_ERRORS_ARE_FATAL</code> behavior at runtime
by calling <code>icalerror_set_errors_are_fatal(0)</code> (i.e, errors are not fatal)
or <code>icalerror_set_errors_are_fatal(1)</code> (i.e, errors are fatal).</p>
<h3 id="57-naming-standard"><a class="header" href="#57-naming-standard">5.7 Naming Standard</a></h3>
<p>Structures that you access with the "struct" keyword, such as <code>struct icaltimetype</code> are things that you are allowed to see inside and poke
at.</p>
<p>Structures that you access though a typedef, such as <code>icalcomponent</code>
are things where all of the data is hidden.</p>
<p>Component names that start with "V" are part of RFC5545 or another
iCal standard. Component names that start with "X" are also part of
the spec, but they are not actually components in the spec. However,
they look and act like components, so they are components in libical.
Names that start with <code>XLIC</code> or <code>X-LIC</code> are not part of any iCal spec.
They are used internally by libical.</p>
<p>Enums that identify a component, property, value or parameter end with
<code>_COMPONENT</code>, <code>_PROPERTY</code>, <code>_VALUE</code>, or <code>_PARAMETER</code>"</p>
<p>Enums that identify a parameter value have the name of the parameter
as the second word. For instance: <code>ICAL_ROLE_REQPARTICIPANT</code> or
<code>ICAL_PARTSTAT_ACCEPTED</code>.</p>
<p>The enums for the parts of a recurrence rule and request statuses
are irregular.</p>
<h2 id="6-hacks-and-bugs"><a class="header" href="#6-hacks-and-bugs">6 Hacks and Bugs</a></h2>
<p>There are a lot of hacks in the library -- bits of code that I am not
proud of and should probably be changed. These are marked with the
comment string "HACK."</p>
<h2 id="7-library-reference"><a class="header" href="#7-library-reference">7 Library Reference</a></h2>
<h3 id="71-manipulating-struct-icaltimetype"><a class="header" href="#71-manipulating-struct-icaltimetype">7.1 Manipulating struct icaltimetype</a></h3>
<h4 id="711-struct-icaltimetype"><a class="header" href="#711-struct-icaltimetype">7.1.1 Struct icaltimetype</a></h4>
<pre><code class="language-c">struct icaltimetype

{
    int year;
    int month;
    int day;
    int hour;
    int minute;
    int second;
    int is_utc;
    int is_date;
    const char* zone;
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migrating-to-version-4"><a class="header" href="#migrating-to-version-4">Migrating to version 4</a></h1>
<p>A guide to help developers port their code from libical v3.x to libical 4.0.</p>
<h2 id="conditional-compilation"><a class="header" href="#conditional-compilation">Conditional compilation</a></h2>
<p>To continue supporting the 3.0 version you can use conditional compilation, like so:</p>
<pre><code class="language-C">     #if ICAL_CHECK_VERSION(4,0,0)
     &lt;...new code for the libical 4.0 version ...&gt;
     #else
     &lt;...old code for the libical 3.0 version ...&gt;
     #endif
</code></pre>
<p>you can handle code that no longer exists in 4.0 with:</p>
<pre><code class="language-C">     #if !ICAL_CHECK_VERSION(4,0,0)
     &lt;...old code for the libical 3.0 version ...&gt;
     #endif
</code></pre>
<h2 id="c-library"><a class="header" href="#c-library">C library</a></h2>
<h3 id="modified-functions"><a class="header" href="#modified-functions">Modified functions</a></h3>
<ul>
<li>
<p><code>icalrecurrencetype_from_string()</code> was replaced by <code>icalrecurrencetype_new_from_string()</code>,
which returns a <code>struct icalrecurrencetype *</code> rather than a <code>struct icalrecurrencetype</code>.</p>
</li>
<li>
<p>The following functions now take arguments of type <code>struct icalrecurrencetype *</code> rather than
<code>struct icalrecurrencetype</code>:</p>
<ul>
<li><code>icalproperty_new_rrule()</code></li>
<li><code>icalproperty_get_rrule()</code></li>
<li><code>icalproperty_set_rrule()</code></li>
<li><code>icalproperty_vanew_rrule()</code></li>
<li><code>icalproperty_new_exrule()</code></li>
<li><code>icalproperty_set_exrule()</code></li>
<li><code>icalproperty_get_exrule()</code></li>
<li><code>icalproperty_vanew_exrule()</code></li>
<li><code>icalrecur_iterator_new()</code></li>
<li><code>icalvalue_new_recur()</code></li>
<li><code>icalvalue_set_recur()</code></li>
<li><code>icalvalue_get_recur()</code></li>
</ul>
</li>
<li>
<p>The following functions now return a value of type <code>struct icalrecurrencetype *</code> rather than
<code>struct icalrecurrencetype</code>:</p>
<ul>
<li><code>icalproperty_get_rrule()</code></li>
<li><code>icalproperty_get_exrule()</code></li>
<li><code>icalvalue_get_recur()</code></li>
</ul>
</li>
</ul>
<h3 id="new-functions"><a class="header" href="#new-functions">New functions</a></h3>
<p>The following functions have been added:</p>
<ul>
<li><code>icalrecurrencetype_new()</code></li>
<li><code>icalrecurrencetype_ref()</code></li>
<li><code>icalrecurrencetype_unref()</code></li>
<li><code>icalrecurrencetype_clone()</code></li>
<li><code>icalrecurrencetype_encode_day()</code></li>
<li><code>icalrecurrencetype_encode_month()</code></li>
<li><code>icaltzutil_set_zone_directory()</code></li>
<li><code>icalcomponent_clone()</code></li>
<li><code>icalproperty_clone()</code></li>
<li><code>icalparameter_clone()</code></li>
<li><code>icalvalue_clone()</code></li>
<li><code>icalcluster_clone()</code></li>
<li><code>icalrecur_iterator_prev()</code></li>
<li><code>icalrecur_resize_by()</code></li>
<li><code>icalrecurrencetype_new()</code></li>
<li><code>icalrecurrencetype_ref()</code></li>
<li><code>icalrecurrencetype_unref()</code></li>
<li><code>icalrecurrencetype_clone()</code></li>
<li><code>icalrecurrencetype_from_string()</code></li>
<li><code>icalcomponent_set_x_name()</code></li>
<li><code>icalcomponent_get_x_name()</code></li>
<li><code>icalcomponent_get_component_name()</code></li>
<li><code>icalcomponent_get_component_name_r()</code></li>
<li><code>ical_set_invalid_rrule_handling_setting()</code></li>
<li><code>ical_get_invalid_rrule_handling_setting()</code></li>
<li><code>icalparser_get_ctrl()</code></li>
<li><code>icalparser_set_ctrl()</code></li>
</ul>
<h3 id="removed-functions"><a class="header" href="#removed-functions">Removed functions</a></h3>
<ul>
<li>
<p><code>icalrecurrencetype_clear()</code> has been removed.</p>
</li>
<li>
<p>These deprecated functions have been removed:</p>
<ul>
<li><code>caldat()</code></li>
<li><code>juldat()</code></li>
<li><code>icalcomponent_new_clone()</code></li>
<li><code>icalparameter_new_clone()</code></li>
<li><code>icalproperty_new_clone()</code></li>
<li><code>icalvalue_new_clone()</code></li>
<li><code>icalcluster_new_clone()</code></li>
</ul>
</li>
<li>
<p>No longer publicly visible functions:</p>
<ul>
<li><code>icaltzutil_fetch_timezone()</code></li>
<li><code>icalrecurrencetype_clear()</code></li>
</ul>
</li>
</ul>
<h3 id="removed-data-types"><a class="header" href="#removed-data-types">Removed data types</a></h3>
<ul>
<li>These data structures have been removed (as they were never used):
<ul>
<li>struct icaltimezonetype</li>
<li>struct icaltimezonephase</li>
</ul>
</li>
</ul>
<h3 id="migrating-from-30-to-40"><a class="header" href="#migrating-from-30-to-40">Migrating from 3.0 to 4.0</a></h3>
<h3 id="bool-return-values"><a class="header" href="#bool-return-values">bool return values</a></h3>
<p>A number of function signatures have been changed to use 'bool' rather than 'int' types.</p>
<p>This is implemented using the C99 standards compliant &lt;stdbool.h&gt; header.</p>
<h3 id="clone-functions"><a class="header" href="#clone-functions">Clone functions</a></h3>
<p>Replace all <code>ical*_new_clone()</code> function calls with <code>ical*_clone()</code> .
ie, use <code>icalcomponent_clone()</code> rather then <code>icalcomponent_new_clone()</code>.</p>
<h3 id="icalrecurrencetype-now-passed-by-reference"><a class="header" href="#icalrecurrencetype-now-passed-by-reference"><code>icalrecurrencetype</code> now passed by reference</a></h3>
<p>The way <code>struct icalrecurrencetype</code> is passed between functions has been changed. While it was
usually passed by value in 3.0, it is now passed by reference. A reference counting mechanism is
applied that takes care of de-allocating an instance as soon as the reference counter goes to 0.</p>
<p>Code like this in libical 3.0:</p>
<pre><code class="language-C">    struct icalrecurrencetype recur;

    icalrecurrencetype_clear(&amp;recur);

    // Work with the object
</code></pre>
<p>changes to this in libical 4.0:</p>
<pre><code class="language-C">    struct icalrecurrencetype *recur;

    // allocate
    recur = icalrecurrencetype_new();
    if (recur) {

        // Work with the object

        // deallocate
        icalrecurrencetype_unref(recur);
    } else {
        // out of memory error handling
    }
</code></pre>
<h3 id="icalgeotype-now-uses-character-strings-rather-than-doubles"><a class="header" href="#icalgeotype-now-uses-character-strings-rather-than-doubles"><code>icalgeotype</code> now uses character strings rather than doubles</a></h3>
<p>The members of <code>struct icalgeotype</code> for latitude ('lat<code>) and longitude ('lon</code>) have been changed
to use ICAL_GEO_LEN long character strings rather than the double type.</p>
<p>This means that simple assignments in 3.0 must be replaced by string copies.</p>
<pre><code class="language-C">     geo.lat = 0.0;
     geo.lon = 10.0;
</code></pre>
<p>becomes</p>
<pre><code class="language-C">     strncpy(geo.lat, "0.0", ICAL_GEO_LEN-1);
     strncpy(geo.lon, "10.0", ICAL_GEO_LEN-1);
</code></pre>
<p>and</p>
<pre><code class="language-C">    double lat = geo.lat;
    double lon = geo.lon;
</code></pre>
<p>becomes</p>
<pre><code class="language-C">    double lat, lon;
    sscanf(geo.lat, "%lf", &amp;lat);
    sscanf(geo.lon, "%lf", &amp;lon);
</code></pre>
<h3 id="working-with-icalvalue-and-icalproperty"><a class="header" href="#working-with-icalvalue-and-icalproperty">Working with <code>icalvalue</code> and <code>icalproperty</code></a></h3>
<p>Code like this in libical 3.0:</p>
<pre><code class="language-C">    icalvalue *recur_value = ...;
    struct icalrecurrencetype recur = icalvalue_get_recur(recur_value);

    // Work with the object
</code></pre>
<p>changes to this in libical 4.0:</p>
<pre><code class="language-C">    icalvalue *recur_value = ...;
    struct icalrecurrencetype *recur = icalvalue_get_recur(recur_value);

    // Work with the object
    // No need to unref
</code></pre>
<h2 id="c-library-1"><a class="header" href="#c-library-1">C++ library</a></h2>
<h3 id="modified-methods"><a class="header" href="#modified-methods">Modified methods</a></h3>
<ul>
<li>
<p>The following methods now take arguments of type <code>struct icalrecurrencetype *</code> rather than <code>const  struct icalrecurrencetype &amp;</code>:</p>
<ul>
<li><code>ICalValue.set_recur()</code></li>
<li><code>ICalProperty.set_exrule()</code></li>
<li><code>ICalProperty.set_rrule()</code></li>
</ul>
</li>
<li>
<p>The following methods now returns a value of type <code>struct icalrecurrencetype *</code> rather than
<code>struct icalrecurrencetype</code>:</p>
<ul>
<li><code>ICalValue.get_recur()</code></li>
<li><code>ICalProperty.get_exrule()</code></li>
<li><code>ICalProperty.get_rrule()</code></li>
</ul>
</li>
</ul>
<h3 id="icalrecurrencetypeby_xxx-static-arrays-replaced-by-dynamically-allocated-ones"><a class="header" href="#icalrecurrencetypeby_xxx-static-arrays-replaced-by-dynamically-allocated-ones"><code>icalrecurrencetype.by_xxx</code> static arrays replaced by dynamically allocated ones</a></h3>
<p>I.e. memory <code>short by_hour[ICAL_BY_DAY_SIZE]</code> etc. are replaced by</p>
<pre><code class="language-c">typedef struct
{
  short *data;
  short size;
} icalrecurrence_by_data;

struct icalrecurrencetype {
  ...
  icalrecurrence_by_data by[ICAL_BY_NUM_PARTS];
}
</code></pre>
<p>Memory is allocated in the required size using the new <code>icalrecur_resize_by()</code> function. It is
automatically freed together with the containing <code>icalrecurrencetype</code>. As the size of the array is
stored explicitly, no termination of the array with special value <code>ICAL_RECURRENCE_ARRAY_MAX</code> is
required anymore.  The array is iterated by comparing the iterator to the <code>size</code> member value.</p>
<h3 id="migrating-icalrecurrencetypeby_xxx-static-arrays-usage-from-30-to-40"><a class="header" href="#migrating-icalrecurrencetypeby_xxx-static-arrays-usage-from-30-to-40">Migrating <code>icalrecurrencetype.by_xxx</code> static arrays usage from 3.0 to 4.0</a></h3>
<p>Code like this in libical 3.0:</p>
<pre><code class="language-C">    icalrecurrencetype recur;
    ...
    recur.by_hour[0] = 12;
    recur.by_hour[1] = ICAL_RECURRENCE_ARRAY_MAX;
</code></pre>
<p>changes to something like this in libical 4.0:</p>
<pre><code class="language-C">    icalrecurrencetype *recur;
    ...
    if (!icalrecur_resize_by(&amp;recur-&gt;by[ICAL_BY_HOUR], 1)) {
      // allocation failed
      // error handling
    } else {
      recur.by[ICAL_BY_HOUR].data[0] = 12;
    }
</code></pre>
<h2 id="glibpython-bindings---changed-icalglibrecurrence_by_-methods"><a class="header" href="#glibpython-bindings---changed-icalglibrecurrence_by_-methods">GLib/Python bindings - changed <code>ICalGLib.Recurrence.*_by_*</code> methods</a></h2>
<p><code>i_cal_recurrence_*_by_xxx*</code> methods have been replaced by more generic versions that take the 'by'
type (day, month, ...) as a parameter.</p>
<h3 id="migrating-icalglibrecurrence_by_-methods-from-30-to-40"><a class="header" href="#migrating-icalglibrecurrence_by_-methods-from-30-to-40">Migrating <code>ICalGLib.Recurrence.*_by_*</code> methods from 3.0 to 4.0</a></h3>
<p>Code like this in libical 3.0:</p>
<pre><code class="language-python">    recurrence.set_by_second(0,
    recurrence.get_by_second(0) + 1)
</code></pre>
<p>changes to something like this in libical 4.0:</p>
<pre><code class="language-python">    recurrence.set_by(ICalGLib.RecurrenceByRule.BY_SECOND, 0,
    recurrence.get_by(ICalGLib.RecurrenceByRule.BY_SECOND, 0) + 1)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="known-limitations"><a class="header" href="#known-limitations">Known Limitations</a></h1>
<p>List where libical doesn't fully support all the features described in the RFCs.</p>
<p>Contributions to help us fix these limitations are welcome.</p>
<h2 id="rfc-5545"><a class="header" href="#rfc-5545">RFC 5545</a></h2>
<h3 id="recurrence-rule-section-3310"><a class="header" href="#recurrence-rule-section-3310">Recurrence Rule section 3.3.10</a></h3>
<ul>
<li>
<p>BYSETPOS is only supported for MONTHLY and YEARLY frequencies (<a href="https://github.com/libical/libical/issues/795">https://github.com/libical/libical/issues/795</a>)</p>
</li>
<li>
<p>FREQ=YEARLY, BYYEARDAY can't be combined with BYWEEKNO, BYMONTH or BYMONTHDAY</p>
<p>ref: <a href="https://github.com/libical/libical/blob/cfd401b9d043214395888de1d9daf52263e3245b/src/libical/icalrecur.c#L2882">https://github.com/libical/libical/blob/cfd401b9d043214395888de1d9daf52263e3245b/src/libical/icalrecur.c#L2882</a></p>
</li>
<li>
<p>FREQ=YEARLY, BYWEEKNO can't be combined with BYYEARDAY, BYMONTH or BYMONTHDAY</p>
<p>ref: <a href="https://github.com/libical/libical/blob/cfd401b9d043214395888de1d9daf52263e3245b/src/libical/icalrecur.c#L2928">https://github.com/libical/libical/blob/cfd401b9d043214395888de1d9daf52263e3245b/src/libical/icalrecur.c#L2928</a></p>
</li>
</ul>
<h3 id="recurrence-rule-sections-3853-duration-336"><a class="header" href="#recurrence-rule-sections-3853-duration-336">Recurrence Rule sections 3.8.5.3, DURATION 3.3.6</a></h3>
<ul>
<li>
<p>The lib (e.g. <code>icalcomponent_foreach_recurrence()</code>, <code>icalcomponent_get_dtend()</code>) does not
differentiate between nominal and exact durations. According to the RFC, when a component's
duration is specified using the <code>DURATION</code> property rather than <code>DTEND</code>, the nominal duration
must be used to calculate each recurrence's duration. However, the current implementation always
uses the exact duration, which can cause discrepancies if a recurrence spans a daylight saving
time transition.</p>
<p>ref: <a href="https://github.com/libical/libical/issues/630">https://github.com/libical/libical/issues/630</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libical-rfc-calendar-standards-support"><a class="header" href="#libical-rfc-calendar-standards-support">Libical RFC calendar standards support</a></h1>
<p><a id="rfcs"></a>
Libical implements the RFCS:</p>
<ul>
<li><a href="https://tools.ietf.org/html/rfc5545">RFC5545</a> Internet Calendaring and Scheduling Core Object Specification (iCalendar)</li>
<li><a href="https://tools.ietf.org/html/rfc5546">RFC5546</a> iCalendar Transport-Independent Interoperability Protocol (iTIP)</li>
<li><a href="https://tools.ietf.org/html/rfc7529">RFC7529</a> Non-Gregorian Recurrence Rules in the Internet Calendaring and
Scheduling Core Object Specification (iCalendar)</li>
</ul>
<p>as well as iCalendar extensions described in:</p>
<ul>
<li><a href="https://tools.ietf.org/html/rfc7986">RFC7986</a> New Properties for iCalendar</li>
<li><a href="https://tools.ietf.org/html/rfc9073">RFC9073</a> Event Publishing Extensions to iCalendar</li>
<li><a href="https://tools.ietf.org/html/rfc9074">RFC9074</a> "VALARM" Extensions for iCalendar</li>
<li><a href="https://tools.ietf.org/html/rfc9253">RFC9253</a> Support for iCalendar Relationships</li>
</ul>
<p>Plus:</p>
<ul>
<li><a href="https://tools.ietf.org/html/rfc6047">RFC6047</a> iCalendar Message-Based Interoperability Protocol (iMIP)</li>
<li><a href="https://tools.ietf.org/html/rfc6638">RFC6638</a> Scheduling Extensions to CalDAV</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributors"><a class="header" href="#contributors">Contributors</a></h1>
<p>The Libical project was founded in 1999 (or perhaps earlier) by Eric Busboom <a href="mailto:eric@clarinova.com">eric@clarinova.com</a>.</p>
<p>We use the term "Contributors to the Libical project" to indicate the current active developers,
to include and not limited to:</p>
<ul>
<li>Allen Winter <a href="mailto:winter@kde.org">winter@kde.org</a> (Maintainer)</li>
<li>Eric Busboom <a href="mailto:eric@clarinova.com">eric@clarinova.com</a> (Founder)</li>
<li>Ken Murchison <a href="mailto:murch@fastmail.com">murch@fastmail.com</a></li>
<li>Kent Sutherland <a href="mailto:git@ksuther.com">git@ksuther.com</a></li>
<li>Markus Minichmayr <a href="mailto:markus@tapkey.com">markus@tapkey.com</a></li>
<li>Milan Crha <a href="mailto:mcrha@redhat.com">mcrha@redhat.com</a></li>
<li>Corentin Noël <a href="mailto:corentin@elementary.io">corentin@elementary.io</a></li>
</ul>
<p>There are now far too many Libical contributors to list here.
See the commit history for the complete list.</p>
<p>From pre-2015 (the first 15 years) we recognize these people who contributed by means
outside of a version control system:</p>
<ul>
<li>
<p>Allan Clark <a href="mailto:allanc@atlas.platypus.bc.ca">allanc@atlas.platypus.bc.ca</a> for testing libical against UnixWare.</p>
</li>
<li>
<p>Graham Davison <a href="mailto:g.m.davison@computer.org">g.m.davison@computer.org</a> for MacOS support and miscellaneous code bits</p>
</li>
<li>
<p>Seth Alves <a href="mailto:alves@hungry.com">alves@hungry.com</a> for the first cut at the Makefile.am files and various utility functions.</p>
</li>
<li>
<p>Russ Steinthal <a href="mailto:rms39@columbia.edu">rms39@columbia.edu</a> for several utility functions and comments.</p>
</li>
<li>
<p>Ola Lundqvist <a href="mailto:olalu526@student.liu.se">olalu526@student.liu.se</a> for the vCal test data file.</p>
</li>
<li>
<p>Colin DuPlantis <a href="mailto:colin@cp.net">colin@cp.net</a> for new functions in icalparser.c</p>
</li>
<li>
<p>Holger Schmidt <a href="mailto:hschmidt@chronolabs.de">hschmidt@chronolabs.de</a> for all of icalcstp.c, The CSTP protocol implementation,
and modifications to icalcstp.h</p>
</li>
<li>
<p>Gisle Hannemyr <a href="mailto:gisle@oslonett.no">gisle@oslonett.no</a> The decode*() functions in sspm.c are based on the decode()
routine in the mimelite program, Copyright (c) 1994 Gisle Hannemyr.</p>
</li>
<li>
<p>The Evolution team at Helixcode for miscellaneous patches and adjustments to the build system:</p>
<ul>
<li>Federico Mena Quintero <a href="mailto:federico@helixcode.com">federico@helixcode.com</a></li>
<li>JP Rosevear <a href="mailto:jpr@helixcode.com">jpr@helixcode.com</a></li>
<li>Ettore Perazzoli <a href="mailto:ettore@helixcode.com">ettore@helixcode.com</a></li>
<li>Christopher James Lahey <a href="mailto:clahey@helixcode.com">clahey@helixcode.com</a></li>
<li>Peter Williams <a href="mailto:peterw@helixcode.com">peterw@helixcode.com</a>)</li>
</ul>
</li>
<li>
<p>Cornelius Schumacher <a href="mailto:schumacher@kde.org">schumacher@kde.org</a> for many insightful suggestions and a few patches.</p>
</li>
<li>
<p>Mark D. Anderson <a href="mailto:mda@discerning.com">mda@discerning.com</a> for discussions and ideas.</p>
</li>
<li>
<p>Martin Neimeier <a href="mailto:nei@ibn.de">nei@ibn.de</a> for correcting bugs in icalrecur.c</p>
</li>
<li>
<p>Tom Leitner <a href="mailto:tom@radar.tu-graz.ac.at">tom@radar.tu-graz.ac.at</a> For several bug fixes in compiling on Tru64 UNIX.</p>
</li>
<li>
<p>Patrick Lewis <a href="mailto:plewis@inetarena.com">plewis@inetarena.com</a> for several bug reports and substantial (co-authorship)
contributions to the Python bindings</p>
</li>
<li>
<p>Larry W. Virden <a href="mailto:lvirden@cas.org">lvirden@cas.org</a> for several bug reports in compiling on Solaris.</p>
</li>
<li>
<p>Bryan Bartone <a href="mailto:bsb@mesasys.com">bsb@mesasys.com</a> for code changes based on porting libical to Windows.</p>
</li>
<li>
<p>Hubert V <a href="mailto:hubertv@bigfoot.com">hubertv@bigfoot.com</a> for checking and analyzing the output of the recurrence rule system.</p>
</li>
<li>
<p>Jonathan Yue <a href="mailto:jonathan.yue@cp.net">jonathan.yue@cp.net</a> for icalproperty_get_name()</p>
</li>
<li>
<p>Jeff Mace <a href="mailto:jhm18@psu.edu">jhm18@psu.edu</a> for finding bugs in gauges.</p>
</li>
<li>
<p>John Gray <a href="mailto:gray@agora-net.com">gray@agora-net.com</a> for routing memory leaks, porting to WIN32, and taking over
leadership of the project.</p>
</li>
<li>
<p>Andrea Campi <a href="mailto:a.campi@inet.it">a.campi@inet.it</a> for miscellaneous updates and beginning of Doxygen documentation.</p>
</li>
<li>
<p>Paul Lindner <a href="mailto:plindner@cp.net">plindner@cp.net</a> for several contributions, including C++ binding, reentrant parser,
thread safe memory allocator, and a lot of documentation.</p>
</li>
<li>
<p>Mark Tearle <a href="mailto:mtearle@tearle.com">mtearle@tearle.com</a> for keeping the Python bindings up to date.</p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
