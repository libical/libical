<!--
  Copyright (C) 2015 William Yu <williamyu@gnome.org>

  This library is free software: you can redistribute it and/or modify it
  under the terms of version 2.1. of the GNU Lesser General Public License
  as published by the Free Software Foundation.

  This library is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License
  for more details.

  You should have received a copy of the GNU Lesser General Public License
  along with this library. If not, see <https://www.gnu.org/licenses/>.
-->
<structure namespace="ICal" name="Recurrence" native="struct icalrecurrencetype" is_bare="true" default_native="i_cal_recurrence_new_default ()">
     <enum name="ICalRecurrenceFrequency" native_name="icalrecurrencetype_frequency" default_native="I_CAL_NO_RECURRENCE">
        <element name="ICAL_MSEC_RECURRENCE"/>
        <element name="ICAL_SECONDLY_RECURRENCE"/>
        <element name="ICAL_MINUTELY_RECURRENCE"/>
        <element name="ICAL_HOURLY_RECURRENCE"/>
        <element name="ICAL_DAILY_RECURRENCE"/>
        <element name="ICAL_WEEKLY_RECURRENCE"/>
        <element name="ICAL_MONTHLY_RECURRENCE"/>
        <element name="ICAL_YEARLY_RECURRENCE"/>
        <element name="ICAL_NO_RECURRENCE"/>
    </enum>
    <enum name="ICalRecurrenceWeekday" native_name="icalrecurrencetype_weekday" default_native="I_CAL_NO_WEEKDAY">
        <element name="ICAL_NO_WEEKDAY"/>
        <element name="ICAL_SUNDAY_WEEKDAY"/>
        <element name="ICAL_MONDAY_WEEKDAY"/>
        <element name="ICAL_TUESDAY_WEEKDAY"/>
        <element name="ICAL_WEDNESDAY_WEEKDAY"/>
        <element name="ICAL_THURSDAY_WEEKDAY"/>
        <element name="ICAL_FRIDAY_WEEKDAY"/>
        <element name="ICAL_SATURDAY_WEEKDAY"/>
    </enum>
    <enum name="ICalRecurrenceSkip" native_name="icalrecurrencetype_skip" default_native="I_CAL_SKIP_UNDEFINED">
        <element name="ICAL_SKIP_BACKWARD"/>
        <element name="ICAL_SKIP_FORWARD"/>
        <element name="ICAL_SKIP_OMIT"/>
        <element name="ICAL_SKIP_UNDEFINED"/>
	</enum>
    <enum name="ICalRecurrenceArrayMaxValues" native_name="enum icalrecurrence_array_max_values" default_native="I_CAL_RECURRENCE_ARRAY_MAX">
	<element name="ICAL_RECURRENCE_ARRAY_MAX"/>
	<!-- Skip this one, it confuses git generator (no name for the first,
	     because it's all part of this one. Furthermore, this one is not
	     used in public.
	<element name="ICAL_RECURRENCE_ARRAY_MAX_BYTE"/>
	-->
    </enum>
    <!-- Not a real enum, those are defines in libical -->
    <enum name="ICalRecurrenceArraySizes" native_name="CUSTOM" default_native="I_CAL_BY_SECOND_SIZE">
        <element name="ICAL_BY_SECOND_SIZE"/>
        <element name="ICAL_BY_MINUTE_SIZE"/>
        <element name="ICAL_BY_HOUR_SIZE"/>
        <element name="ICAL_BY_MONTH_SIZE"/>
        <element name="ICAL_BY_MONTHDAY_SIZE"/>
        <element name="ICAL_BY_WEEKNO_SIZE"/>
        <element name="ICAL_BY_YEARDAY_SIZE"/>
        <element name="ICAL_BY_SETPOS_SIZE"/>
        <element name="ICAL_BY_DAY_SIZE"/>
    </enum>
    <method name="i_cal_recurrence_rscale_is_supported" corresponds="icalrecurrencetype_rscale_is_supported" kind="get" since="2.0">
	<returns type="gboolean" comment="Whether rscale is supported"/>
	<comment xml:space="preserve">Checks whether rscale is supported.</comment>
    </method>
    <method name="i_cal_recurrence_rscale_supported_calendars" corresponds="icalrecurrencetype_rscale_supported_calendars" kind="other" since="2.0">
	<returns type="ICalArray *" annotation="transfer full" translator_argus="NULL, FALSE" comment="Array of calendars. Currently always NULL."/>
	<comment xml:space="preserve">Gets an array of calendars supporting rscale (currently always return NULL).</comment>
    </method>
    <method name="i_cal_recurrence_new_default" corresponds="CUSTOM" annotation="skip" kind="private" since="1.0">
        <returns type="struct icalrecurrencetype" comment="The default value."/>
        <custom>	struct icalrecurrencetype ret;
	icalrecurrencetype_clear (&amp;ret);
	return ret;</custom>
    </method>
    <method name="i_cal_recurrence_new" corresponds="CUSTOM" kind="constructor" since="1.0">
        <returns type="ICalRecurrence *" annotation="transfer full" comment="The newly created #ICalRecurrence." />
        <comment xml:space="preserve">Creates a new #ICalRecurrence.</comment>
        <custom>	return i_cal_recurrence_new_full(i_cal_recurrence_new_default());</custom>
    </method>
    <method name="i_cal_recurrence_clear" corresponds="icalrecurrencetype_clear" since="1.0">
        <parameter type="ICalRecurrence *" name="r" native_op="POINTER" comment="The #ICalRecurrence to be reset"/>
        <comment xml:space="preserve">Resets an #ICalRecurrence.</comment>
    </method>
    <method name="i_cal_recurrence_day_day_of_week" corresponds="icalrecurrencetype_day_day_of_week" since="1.0">
        <parameter type="gshort" name="day" comment="The encoded day which represents the day of the week and Nth day of the week"/>
        <returns type="ICalRecurrenceWeekday" comment="The decoded weekday with Monday to be 1."/>
        <comment xml:space="preserve">Decodes a day to a weekday in a week.</comment>
    </method>
    <method name="i_cal_recurrence_day_position" corresponds="icalrecurrencetype_day_position" since="1.0">
        <parameter type="gshort" name="day" comment="The encoded day which represents the day of the week and Nth day of the week"/>
        <returns type="gint" comment="The decoded day of the week. 0 == any of day of week. 1 == first, 2 = second, -2 == second to last, etc"/>
        <comment xml:space="preserve">Decodes a day to a position of the weekday.</comment>
    </method>
    <method name="i_cal_recurrence_encode_day" corresponds="icalrecurrencetype_encode_day" since="3.0.5">
        <parameter type="ICalRecurrenceWeekday" name="weekday" comment="The #ICalRecurrenceWeekday to use."/>
        <parameter type="gint" name="position" comment="The position to use. 0 == any of day of week. 1 == first, 2 = second, -2 == second to last, etc"/>
        <returns type="gshort" comment="Encoded @weekday and @position into a single value"/>
        <comment xml:space="preserve">Encodes the @weekday and @position into a single value, which can by split by i_cal_recurrence_day_day_of_week() and i_cal_recurrence_day_position().</comment>
    </method>
    <method name="i_cal_recurrence_month_is_leap" corresponds="icalrecurrencetype_month_is_leap" since="2.0">
        <parameter type="gshort" name="month" comment="The month to be decoded"/>
        <returns type="gboolean" comment="Whether this month is a leap month."/>
        <comment xml:space="preserve">Decodes a month and check whether it is a leap month.</comment>
    </method>
    <method name="i_cal_recurrence_month_month" corresponds="icalrecurrencetype_month_month" since="2.0">
        <parameter type="gshort" name="month" comment="The month to be decoded"/>
        <returns type="gint" comment="The actual month number regardless of the leap flag."/>
        <comment xml:space="preserve">Decode a month from an encoded value by i_cal_recurrence_encode_month().</comment>
    </method>
    <method name="i_cal_recurrence_encode_month" corresponds="icalrecurrencetype_encode_month" since="3.0.5">
        <parameter type="gint" name="month" comment="The month to be encoded"/>
        <parameter type="gboolean" name="is_leap" comment="%TRUE, when the month is leap, %FALSE otherwise"/>
        <returns type="gshort" comment="Encoded @month and @is_leap"/>
        <comment xml:space="preserve">Encodes the @month and the @is_leap flag into a single value, which can be split by i_cal_recurrence_month_is_leap() and i_cal_recurrence_month_month().</comment>
    </method>
    <method name="i_cal_recurrence_new_from_string" corresponds="icalrecurrencetype_from_string" since="1.0">
        <parameter type="const gchar *" name="str" comment="The string representation of the #ICalRecurrence"/>
        <returns type="ICalRecurrence *" annotation="transfer full" comment="The #ICalRecurrence converted from @str."/>
        <comment xml:space="preserve">Converts a string to a #ICalRecurrence.</comment>
    </method>
    <method name="i_cal_recurrence_to_string" corresponds="icalrecurrencetype_as_string_r" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" native_op="POINTER" comment="The #ICalRecurrence to be converted"/>
        <returns type="gchar *" annotation="transfer full" comment="The string representation of @recur."/>
        <comment xml:space="preserve">Converts a #ICalRecurrence to a string.</comment>
    </method>
    <method name="i_cal_recurrence_get_until" corresponds="CUSTOM" kind="get" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <returns type="ICalTime *" annotation="transfer full" comment="The until of #ICalRecurrence."/>
        <comment>Gets the until from #ICalRecurrence.</comment>
        <custom>	g_return_val_if_fail (recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur), NULL);
	return i_cal_time_new_full (((struct icalrecurrencetype *)i_cal_object_get_native ((ICalObject *)recur))->until);</custom>
    </method>
    <method name="i_cal_recurrence_set_until" corresponds="CUSTOM" kind="set" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <parameter type="ICalTime *" name="until" comment="The until of #ICalRecurrence"/>
        <comment>Sets the until from #ICalRecurrence.</comment>
        <custom>	g_return_if_fail (recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur));
	g_return_if_fail (until != NULL &amp;&amp; I_CAL_IS_TIME(until));
	((struct icalrecurrencetype *)i_cal_object_get_native ((ICalObject *)recur))->until = *(icaltimetype *)i_cal_object_get_native ((ICalObject *)until);</custom>
    </method>
    <method name="i_cal_recurrence_get_freq" corresponds="CUSTOM" kind="get" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <returns type="ICalRecurrenceFrequency" comment="The freq of #ICalRecurrence."/>
        <comment>Gets the freq from #ICalRecurrence.</comment>
        <custom>	g_return_val_if_fail (recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur), I_CAL_NO_RECURRENCE);
	return (ICalRecurrenceFrequency) (((struct icalrecurrencetype *)i_cal_object_get_native ((ICalObject *)recur))->freq);</custom>
    </method>
    <method name="i_cal_recurrence_set_freq" corresponds="CUSTOM" kind="set" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <parameter type="ICalRecurrenceFrequency" name="freq" comment="The freq of #ICalRecurrence"/>
        <comment>Sets the freq from #ICalRecurrence.</comment>
        <custom>	g_return_if_fail (recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur));
	((struct icalrecurrencetype *) i_cal_object_get_native ((ICalObject *)recur))->freq = (icalrecurrencetype_frequency) freq;</custom>
    </method>
    <method name="i_cal_recurrence_get_count" corresponds="CUSTOM" kind="get" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <returns type="gint" comment="The count of #ICalRecurrence."/>
        <comment>Gets the count from #ICalRecurrence.</comment>
        <custom>	g_return_val_if_fail (recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur), 0);
	return ((struct icalrecurrencetype *)i_cal_object_get_native ((ICalObject *)recur))->count;</custom>
    </method>
    <method name="i_cal_recurrence_set_count" corresponds="CUSTOM" kind="set" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <parameter type="gint" name="count" comment="The count of #ICalRecurrence"/>
        <comment>Sets the count from #ICalRecurrence.</comment>
        <custom>	g_return_if_fail (recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur));
	((struct icalrecurrencetype *)i_cal_object_get_native ((ICalObject *)recur))->count = count;</custom>
    </method>
    <method name="i_cal_recurrence_get_interval" corresponds="CUSTOM" kind="get" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <returns type="gshort" comment="The interval of #ICalRecurrence."/>
        <comment>Gets the interval from #ICalRecurrence.</comment>
        <custom>	g_return_val_if_fail (recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur), 0);
	return ((struct icalrecurrencetype *)i_cal_object_get_native ((ICalObject *)recur))->interval;</custom>
    </method>
    <method name="i_cal_recurrence_set_interval" corresponds="CUSTOM" kind="set" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <parameter type="gshort" name="interval" comment="The interval of #ICalRecurrence"/>
        <comment>Sets the interval from #ICalRecurrence.</comment>
        <custom>	g_return_if_fail (recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur));
	((struct icalrecurrencetype *)i_cal_object_get_native ((ICalObject *)recur))->interval = interval;</custom>
    </method>
    <method name="i_cal_recurrence_get_week_start" corresponds="CUSTOM" kind="get" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <returns type="ICalRecurrenceWeekday" comment="The week_start of #ICalRecurrence."/>
        <comment>Gets the week_start from #ICalRecurrence.</comment>
        <custom>	g_return_val_if_fail (recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur), I_CAL_NO_WEEKDAY);
	return (ICalRecurrenceWeekday) (((struct icalrecurrencetype *)i_cal_object_get_native ((ICalObject *)recur))->week_start);</custom>
    </method>
    <method name="i_cal_recurrence_set_week_start" corresponds="CUSTOM" kind="set" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <parameter type="ICalRecurrenceWeekday" name="week_start" comment="The week_start of #ICalRecurrence"/>
        <comment>Sets the week_start from #ICalRecurrence.</comment>
        <custom>	g_return_if_fail (recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur));
	((struct icalrecurrencetype *)i_cal_object_get_native ((ICalObject *)recur))->week_start = (icalrecurrencetype_weekday) week_start;</custom>
    </method>
    <method name="i_cal_recurrence_get_by_second_array" corresponds="CUSTOM" kind="get" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <returns type="GArray *" annotation="transfer full, element-type gshort" comment="The by_second of #ICalRecurrence."/>
        <comment>Gets the by_second array from #ICalRecurrence. The array size if I_CAL_BY_SECOND_SIZE.</comment>
        <custom>	GArray *array;
	g_return_val_if_fail (recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur), NULL);
	array = g_array_new (FALSE, TRUE, sizeof (gshort));
	g_array_append_vals (array, ((struct icalrecurrencetype *)i_cal_object_get_native ((ICalObject *)recur))->by_second, I_CAL_BY_SECOND_SIZE);
	return array;</custom>
    </method>
    <method name="i_cal_recurrence_set_by_second_array" corresponds="CUSTOM" kind="set" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <parameter type="GArray *" name="values" annotation="element-type gshort" comment="The array of values"/>
        <comment>Sets the by_second array in @recur at once. The array size can be less than I_CAL_BY_SECOND_SIZE. Shorter arrays are terminated with I_CAL_RECURRENCE_ARRAY_MAX value, longer arrays are truncated.</comment>
        <custom>    struct icalrecurrencetype *rt;
    guint ii;

    g_return_if_fail(recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur));
    g_return_if_fail(values != NULL);

    rt = (struct icalrecurrencetype *)i_cal_object_get_native((ICalObject *)recur);
    g_return_if_fail(rt != NULL);

    for(ii = 0; ii &lt; values-&gt;len &amp;&amp; ii &lt; I_CAL_BY_SECOND_SIZE; ii++) {
        rt->by_second[ii] = g_array_index(values, gshort, ii);
    }
    if(ii &lt; I_CAL_BY_SECOND_SIZE)
        rt->by_second[ii] = I_CAL_RECURRENCE_ARRAY_MAX;</custom>
    </method>
    <method name="i_cal_recurrence_get_by_second" corresponds="CUSTOM" kind="get" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <parameter type="guint" name="index" comment="The index in by_second of #ICalRecurrence, less than %I_CAL_BY_SECOND_SIZE"/>
        <returns type="gshort" comment="The by_second of #ICalRecurrence at index @index."/>
        <comment>Gets the by_second value at index @index. The index should be less than %I_CAL_BY_SECOND_SIZE.</comment>
        <custom>    g_return_val_if_fail (recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur), I_CAL_RECURRENCE_ARRAY_MAX);
    g_return_val_if_fail (index &lt; I_CAL_BY_SECOND_SIZE, I_CAL_RECURRENCE_ARRAY_MAX);
    return ((struct icalrecurrencetype *)i_cal_object_get_native ((ICalObject *)recur))->by_second[index];</custom>
    </method>
    <method name="i_cal_recurrence_set_by_second" corresponds="CUSTOM" kind="set" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <parameter type="guint" name="index" comment="The index in by_second of #ICalRecurrence, less than I_CAL_BY_SECOND_SIZE"/>
        <parameter type="gshort" name="value" comment="The value to be set into by_second of #ICalRecurrence"/>
        <comment>Sets the by_second array from #ICalRecurrence at the given index. The array size is I_CAL_BY_SECOND_SIZE.</comment>
        <custom>	g_return_if_fail (recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur));
	g_return_if_fail (index &lt; I_CAL_BY_SECOND_SIZE);
	((struct icalrecurrencetype *)i_cal_object_get_native ((ICalObject *)recur))->by_second[index] = value;</custom>
    </method>
    <method name="i_cal_recurrence_get_by_minute_array" corresponds="CUSTOM" kind="get" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <returns type="GArray *" annotation="transfer full, element-type gshort" comment="The by_minute of #ICalRecurrence."/>
        <comment>Gets the by_minute array from #ICalRecurrence. The array size is I_CAL_BY_MINUTE_SIZE.</comment>
        <custom>	GArray *array;
	g_return_val_if_fail (recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur), NULL);
	array = g_array_new (FALSE, FALSE, sizeof (gshort));
	g_array_append_vals (array, ((struct icalrecurrencetype *)i_cal_object_get_native ((ICalObject *)recur))->by_minute, I_CAL_BY_MINUTE_SIZE);
	return array;</custom>
    </method>
    <method name="i_cal_recurrence_set_by_minute_array" corresponds="CUSTOM" kind="set" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <parameter type="GArray *" name="values" annotation="element-type gshort" comment="The array of values"/>
        <comment>Sets the by_minute array in @recur at once. The array size can be less than I_CAL_BY_MINUTE_SIZE. Shorter arrays are terminated with I_CAL_RECURRENCE_ARRAY_MAX value, longer arrays are truncated.</comment>
        <custom>    struct icalrecurrencetype *rt;
    guint ii;

    g_return_if_fail(recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur));
    g_return_if_fail(values != NULL);

    rt = (struct icalrecurrencetype *)i_cal_object_get_native((ICalObject *)recur);
    g_return_if_fail(rt != NULL);

    for(ii = 0; ii &lt; values-&gt;len &amp;&amp; ii &lt; I_CAL_BY_MINUTE_SIZE; ii++) {
        rt->by_minute[ii] = g_array_index(values, gshort, ii);
    }
    if(ii &lt; I_CAL_BY_MINUTE_SIZE)
        rt->by_minute[ii] = I_CAL_RECURRENCE_ARRAY_MAX;</custom>
    </method>
    <method name="i_cal_recurrence_get_by_minute" corresponds="CUSTOM" kind="get" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <parameter type="guint" name="index" comment="The index in by_minute of #ICalRecurrence, less than %I_CAL_BY_MINUTE_SIZE"/>
        <returns type="gshort" comment="The by_minute of #ICalRecurrence at index @index."/>
        <comment>Gets the by_minute value at index @index. The index should be less than %I_CAL_BY_MINUTE_SIZE.</comment>
        <custom>    g_return_val_if_fail (recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur), I_CAL_RECURRENCE_ARRAY_MAX);
    g_return_val_if_fail (index &lt; I_CAL_BY_MINUTE_SIZE, I_CAL_RECURRENCE_ARRAY_MAX);
    return ((struct icalrecurrencetype *)i_cal_object_get_native ((ICalObject *)recur))->by_minute[index];</custom>
    </method>
    <method name="i_cal_recurrence_set_by_minute" corresponds="CUSTOM" kind="set" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <parameter type="guint" name="index" comment="The index in by_minute of #ICalRecurrence"/>
        <parameter type="gshort" name="value" comment="The value to be set into by_minute of #ICalRecurrence"/>
        <comment>Sets the by_minute array from #ICalRecurrence at the given index. The array size is I_CAL_BY_MINUTE_SIZE.</comment>
        <custom>	g_return_if_fail (recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur));
	g_return_if_fail (index &lt; I_CAL_BY_MINUTE_SIZE);
	((struct icalrecurrencetype *)i_cal_object_get_native ((ICalObject *)recur))->by_minute[index] = value;</custom>
    </method>
    <method name="i_cal_recurrence_get_by_hour_array" corresponds="CUSTOM" kind="get" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <returns type="GArray *" annotation="transfer full, element-type gshort" comment="The by_hour of #ICalRecurrence."/>
        <comment>Gets the by_hour array from #ICalRecurrence. The array size is I_CAL_BY_HOUR_SIZE.</comment>
        <custom>	GArray *array;
	g_return_val_if_fail (recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur), NULL);
	array = g_array_new (FALSE, FALSE, sizeof (gshort));
	g_array_append_vals (array, ((struct icalrecurrencetype *)i_cal_object_get_native ((ICalObject *)recur))->by_hour, I_CAL_BY_HOUR_SIZE);
	return array;</custom>
    </method>
    <method name="i_cal_recurrence_set_by_hour_array" corresponds="CUSTOM" kind="set" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <parameter type="GArray *" name="values" annotation="element-type gshort" comment="The array of values"/>
        <comment>Sets the by_hour array in @recur at once. The array size can be less than I_CAL_BY_HOUR_SIZE. Shorter arrays are terminated with I_CAL_RECURRENCE_ARRAY_MAX value, longer arrays are truncated.</comment>
        <custom>    struct icalrecurrencetype *rt;
    guint ii;

    g_return_if_fail(recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur));
    g_return_if_fail(values != NULL);

    rt = (struct icalrecurrencetype *)i_cal_object_get_native((ICalObject *)recur);
    g_return_if_fail(rt != NULL);

    for(ii = 0; ii &lt; values-&gt;len &amp;&amp; ii &lt; I_CAL_BY_HOUR_SIZE; ii++) {
        rt->by_hour[ii] = g_array_index(values, gshort, ii);
    }
    if(ii &lt; I_CAL_BY_HOUR_SIZE)
        rt->by_hour[ii] = I_CAL_RECURRENCE_ARRAY_MAX;</custom>
    </method>
    <method name="i_cal_recurrence_get_by_hour" corresponds="CUSTOM" kind="get" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <parameter type="guint" name="index" comment="The index in by_hour of #ICalRecurrence, less than %I_CAL_BY_HOUR_SIZE"/>
        <returns type="gshort" comment="The by_hour of #ICalRecurrence at index @index."/>
        <comment>Gets the by_hour value at index @index. The index should be less than %I_CAL_BY_HOUR_SIZE.</comment>
        <custom>    g_return_val_if_fail (recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur), I_CAL_RECURRENCE_ARRAY_MAX);
    g_return_val_if_fail (index &lt; I_CAL_BY_HOUR_SIZE, I_CAL_RECURRENCE_ARRAY_MAX);
    return ((struct icalrecurrencetype *)i_cal_object_get_native ((ICalObject *)recur))->by_hour[index];</custom>
    </method>
    <method name="i_cal_recurrence_set_by_hour" corresponds="CUSTOM" kind="set" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <parameter type="guint" name="index" comment="The index in by_hour of #ICalRecurrence"/>
        <parameter type="gshort" name="value" comment="The value to be set into by_hour of #ICalRecurrence"/>
        <comment>Sets the by_hour array from #ICalRecurrence at the given index. The array size is I_CAL_BY_HOUR_SIZE.</comment>
        <custom>	g_return_if_fail (recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur));
	g_return_if_fail (index &lt; I_CAL_BY_HOUR_SIZE);
	((struct icalrecurrencetype *)i_cal_object_get_native ((ICalObject *)recur))->by_hour[index] = value;</custom>
    </method>
    <method name="i_cal_recurrence_get_by_day_array" corresponds="CUSTOM" kind="get" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <returns type="GArray *" annotation="transfer full, element-type gshort" comment="The by_day of #ICalRecurrence."/>
        <comment>Gets the by_day array from #ICalRecurrence. The array size is I_CAL_BY_DAY_SIZE.</comment>
        <custom>	GArray *array;
	g_return_val_if_fail (recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur), NULL);
	array = g_array_new (FALSE, FALSE, sizeof (gshort));
	g_array_append_vals (array, ((struct icalrecurrencetype *)i_cal_object_get_native ((ICalObject *)recur))->by_day, I_CAL_BY_DAY_SIZE);
	return array;</custom>
    </method>
    <method name="i_cal_recurrence_set_by_day_array" corresponds="CUSTOM" kind="set" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <parameter type="GArray *" name="values" annotation="element-type gshort" comment="The array of values"/>
        <comment>Sets the by_day array in @recur at once. The array size can be less than I_CAL_BY_DAY_SIZE. Shorter arrays are terminated with I_CAL_RECURRENCE_ARRAY_MAX value, longer arrays are truncated.</comment>
        <custom>    struct icalrecurrencetype *rt;
    guint ii;

    g_return_if_fail(recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur));
    g_return_if_fail(values != NULL);

    rt = (struct icalrecurrencetype *)i_cal_object_get_native((ICalObject *)recur);
    g_return_if_fail(rt != NULL);

    for(ii = 0; ii &lt; values-&gt;len &amp;&amp; ii &lt; I_CAL_BY_DAY_SIZE; ii++) {
        rt->by_day[ii] = g_array_index(values, gshort, ii);
    }
    if(ii &lt; I_CAL_BY_DAY_SIZE)
        rt->by_day[ii] = I_CAL_RECURRENCE_ARRAY_MAX;</custom>
    </method>
    <method name="i_cal_recurrence_get_by_day" corresponds="CUSTOM" kind="get" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <parameter type="guint" name="index" comment="The index in by_day of #ICalRecurrence, less than %I_CAL_BY_DAY_SIZE"/>
        <returns type="gshort" comment="The by_day of #ICalRecurrence at index @index."/>
        <comment>Gets the by_day value at index @index. The index should be less than %I_CAL_BY_DAY_SIZE.</comment>
        <custom>    g_return_val_if_fail (recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur), I_CAL_RECURRENCE_ARRAY_MAX);
    g_return_val_if_fail (index &lt; I_CAL_BY_DAY_SIZE, I_CAL_RECURRENCE_ARRAY_MAX);
    return ((struct icalrecurrencetype *)i_cal_object_get_native ((ICalObject *)recur))->by_day[index];</custom>
    </method>
    <method name="i_cal_recurrence_set_by_day" corresponds="CUSTOM" kind="set" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <parameter type="guint" name="index" comment="The index in by_day of #ICalRecurrence"/>
        <parameter type="gshort" name="value" comment="The value to be set into by_day of #ICalRecurrence"/>
        <comment>Sets the by_day array from #ICalRecurrence at the given index. The array size if I_CAL_BY_DAY_SIZE.</comment>
        <custom>	g_return_if_fail (recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur));
	g_return_if_fail (index &lt; I_CAL_BY_DAY_SIZE);
	((struct icalrecurrencetype *)i_cal_object_get_native ((ICalObject *)recur))->by_day[index] = value;</custom>
    </method>
    <method name="i_cal_recurrence_get_by_month_day_array" corresponds="CUSTOM" kind="get" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <returns type="GArray *" annotation="transfer full, element-type gshort" comment="The by_month_day of #ICalRecurrence."/>
        <comment>Gets the by_month_day array from #ICalRecurrence. The array size is I_CAL_BY_MONTHDAY_SIZE.</comment>
        <custom>	GArray *array;
	g_return_val_if_fail (recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur), NULL);
	array = g_array_new (FALSE, FALSE, sizeof (gshort));
	g_array_append_vals (array, ((struct icalrecurrencetype *)i_cal_object_get_native ((ICalObject *)recur))->by_month_day, I_CAL_BY_MONTHDAY_SIZE);
	return array;</custom>
    </method>
    <method name="i_cal_recurrence_set_by_month_day_array" corresponds="CUSTOM" kind="set" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <parameter type="GArray *" name="values" annotation="element-type gshort" comment="The array of values"/>
        <comment>Sets the by_month_day array in @recur at once. The array size can be less than I_CAL_BY_MONTHDAY_SIZE. Shorter arrays are terminated with I_CAL_RECURRENCE_ARRAY_MAX value, longer arrays are truncated.</comment>
        <custom>    struct icalrecurrencetype *rt;
    guint ii;

    g_return_if_fail(recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur));
    g_return_if_fail(values != NULL);

    rt = (struct icalrecurrencetype *)i_cal_object_get_native((ICalObject *)recur);
    g_return_if_fail(rt != NULL);

    for(ii = 0; ii &lt; values-&gt;len &amp;&amp; ii &lt; I_CAL_BY_MONTHDAY_SIZE; ii++) {
        rt->by_month_day[ii] = g_array_index(values, gshort, ii);
    }
    if(ii &lt; I_CAL_BY_MONTHDAY_SIZE)
        rt->by_month_day[ii] = I_CAL_RECURRENCE_ARRAY_MAX;</custom>
    </method>
    <method name="i_cal_recurrence_get_by_month_day" corresponds="CUSTOM" kind="get" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <parameter type="guint" name="index" comment="The index in by_month_day of #ICalRecurrence, less than %I_CAL_BY_MONTHDAY_SIZE"/>
        <returns type="gshort" comment="The by_month_day of #ICalRecurrence at index @index."/>
        <comment>Gets the by_month_day value at index @index. The index should be less than %I_CAL_BY_MONTHDAY_SIZE.</comment>
        <custom>    g_return_val_if_fail (recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur), I_CAL_RECURRENCE_ARRAY_MAX);
    g_return_val_if_fail (index &lt; I_CAL_BY_MONTHDAY_SIZE, I_CAL_RECURRENCE_ARRAY_MAX);
    return ((struct icalrecurrencetype *)i_cal_object_get_native ((ICalObject *)recur))->by_month_day[index];</custom>
    </method>
    <method name="i_cal_recurrence_set_by_month_day" corresponds="CUSTOM" kind="set" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <parameter type="guint" name="index" comment="The index in by_month_day of #ICalRecurrence"/>
        <parameter type="gshort" name="value" comment="The value to be set into by_month_day of #ICalRecurrence"/>
        <comment>Sets the by_month_day array from #ICalRecurrence at the given index. The array size if I_CAL_BY_MONTHDAY_SIZE.</comment>
        <custom>	g_return_if_fail (recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur));
	g_return_if_fail (index &lt; I_CAL_BY_MONTHDAY_SIZE);
	((struct icalrecurrencetype *)i_cal_object_get_native ((ICalObject *)recur))->by_month_day[index] = value;</custom>
    </method>
    <method name="i_cal_recurrence_get_by_year_day_array" corresponds="CUSTOM" kind="get" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <returns type="GArray *" annotation="transfer full, element-type gshort" comment="The by_year_day of #ICalRecurrence."/>
        <comment>Gets the by_year_day array from #ICalRecurrence. The array size is I_CAL_BY_YEARDAY_SIZE.</comment>
        <custom>	GArray *array;
	g_return_val_if_fail (recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur), NULL);
	array = g_array_new (FALSE, FALSE, sizeof (gshort));
	g_array_append_vals (array, ((struct icalrecurrencetype *)i_cal_object_get_native ((ICalObject *)recur))->by_year_day, I_CAL_BY_YEARDAY_SIZE);
	return array;</custom>
    </method>
    <method name="i_cal_recurrence_set_by_year_day_array" corresponds="CUSTOM" kind="set" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <parameter type="GArray *" name="values" annotation="element-type gshort" comment="The array of values"/>
        <comment>Sets the by_year_day array in @recur at once. The array size can be less than I_CAL_BY_YEARDAY_SIZE. Shorter arrays are terminated with I_CAL_RECURRENCE_ARRAY_MAX value, longer arrays are truncated.</comment>
        <custom>    struct icalrecurrencetype *rt;
    guint ii;

    g_return_if_fail(recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur));
    g_return_if_fail(values != NULL);

    rt = (struct icalrecurrencetype *)i_cal_object_get_native((ICalObject *)recur);
    g_return_if_fail(rt != NULL);

    for(ii = 0; ii &lt; values-&gt;len &amp;&amp; ii &lt; I_CAL_BY_YEARDAY_SIZE; ii++) {
        rt->by_year_day[ii] = g_array_index(values, gshort, ii);
    }
    if(ii &lt; I_CAL_BY_YEARDAY_SIZE)
        rt->by_year_day[ii] = I_CAL_RECURRENCE_ARRAY_MAX;</custom>
    </method>
    <method name="i_cal_recurrence_get_by_year_day" corresponds="CUSTOM" kind="get" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <parameter type="guint" name="index" comment="The index in by_year_day of #ICalRecurrence, less than %I_CAL_BY_YEARDAY_SIZE"/>
        <returns type="gshort" comment="The by_year_day of #ICalRecurrence at index @index."/>
        <comment>Gets the by_year_day value at index @index. The index should be less than %I_CAL_BY_YEARDAY_SIZE.</comment>
        <custom>    g_return_val_if_fail (recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur), I_CAL_RECURRENCE_ARRAY_MAX);
    g_return_val_if_fail (index &lt; I_CAL_BY_YEARDAY_SIZE, I_CAL_RECURRENCE_ARRAY_MAX);
    return ((struct icalrecurrencetype *)i_cal_object_get_native ((ICalObject *)recur))->by_year_day[index];</custom>
    </method>
    <method name="i_cal_recurrence_set_by_year_day" corresponds="CUSTOM" kind="set" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <parameter type="guint" name="index" comment="The index in by_year_day of #ICalRecurrence"/>
        <parameter type="gshort" name="value" comment="The value to be set into by_year_day of #ICalRecurrence"/>
        <comment>Sets the by_year_day array from #ICalRecurrence at the given index. The array size if I_CAL_BY_YEARDAY_SIZE.</comment>
        <custom>	g_return_if_fail (recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur));
	g_return_if_fail (index &lt; I_CAL_BY_YEARDAY_SIZE);
	((struct icalrecurrencetype *)i_cal_object_get_native ((ICalObject *)recur))->by_year_day[index] = value;</custom>
    </method>
    <method name="i_cal_recurrence_get_by_week_no_array" corresponds="CUSTOM" kind="get" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <returns type="GArray *" annotation="transfer full, element-type gshort" comment="The by_week_no of #ICalRecurrence."/>
        <comment>Gets the by_week_no array from #ICalRecurrence. The array size is I_CAL_BY_WEEKNO_SIZE.</comment>
        <custom>	GArray *array;
	g_return_val_if_fail (recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur), NULL);
	array = g_array_new (FALSE, FALSE, sizeof (gshort));
	g_array_append_vals (array, ((struct icalrecurrencetype *)i_cal_object_get_native ((ICalObject *)recur))->by_week_no, I_CAL_BY_WEEKNO_SIZE);
	return array;</custom>
    </method>
    <method name="i_cal_recurrence_set_by_week_no_array" corresponds="CUSTOM" kind="set" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <parameter type="GArray *" name="values" annotation="element-type gshort" comment="The array of values"/>
        <comment>Sets the by_week_no array in @recur at once. The array size can be less than I_CAL_BY_WEEKNO_SIZE. Shorter arrays are terminated with I_CAL_RECURRENCE_ARRAY_MAX value, longer arrays are truncated.</comment>
        <custom>    struct icalrecurrencetype *rt;
    guint ii;

    g_return_if_fail(recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur));
    g_return_if_fail(values != NULL);

    rt = (struct icalrecurrencetype *)i_cal_object_get_native((ICalObject *)recur);
    g_return_if_fail(rt != NULL);

    for(ii = 0; ii &lt; values-&gt;len &amp;&amp; ii &lt; I_CAL_BY_WEEKNO_SIZE; ii++) {
        rt->by_week_no[ii] = g_array_index(values, gshort, ii);
    }
    if(ii &lt; I_CAL_BY_WEEKNO_SIZE)
        rt->by_week_no[ii] = I_CAL_RECURRENCE_ARRAY_MAX;</custom>
    </method>
    <method name="i_cal_recurrence_get_by_week_no" corresponds="CUSTOM" kind="get" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <parameter type="guint" name="index" comment="The index in by_week_no of #ICalRecurrence, less than %I_CAL_BY_WEEKNO_SIZE"/>
        <returns type="gshort" comment="The by_week_no of #ICalRecurrence at index @index."/>
        <comment>Gets the by_week_no value at index @index. The index should be less than %I_CAL_BY_WEEKNO_SIZE.</comment>
        <custom>    g_return_val_if_fail (recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur), I_CAL_RECURRENCE_ARRAY_MAX);
    g_return_val_if_fail (index &lt; I_CAL_BY_WEEKNO_SIZE, I_CAL_RECURRENCE_ARRAY_MAX);
    return ((struct icalrecurrencetype *)i_cal_object_get_native ((ICalObject *)recur))->by_week_no[index];</custom>
    </method>
    <method name="i_cal_recurrence_set_by_week_no" corresponds="CUSTOM" kind="set" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <parameter type="guint" name="index" comment="The index in by_week_no of #ICalRecurrence"/>
        <parameter type="gshort" name="value" comment="The value to be set into by_week_no of #ICalRecurrence"/>
        <comment>Sets the by_week_no array from #ICalRecurrence at the given index. The array size is I_CAL_BY_WEEKNO_SIZE.</comment>
        <custom>	g_return_if_fail (recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur));
	g_return_if_fail (index &lt; I_CAL_BY_WEEKNO_SIZE);
	((struct icalrecurrencetype *)i_cal_object_get_native ((ICalObject *)recur))->by_week_no[index] = value;</custom>
    </method>
    <method name="i_cal_recurrence_get_by_month_array" corresponds="CUSTOM" kind="get" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <returns type="GArray *" annotation="transfer full, element-type gshort" comment="The by_month of #ICalRecurrence."/>
        <comment>Gets the by_month array from #ICalRecurrence. The array size is I_CAL_BY_MONTH_SIZE.</comment>
        <custom>	GArray *array;
	g_return_val_if_fail (recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur), NULL);
	array = g_array_new (FALSE, FALSE, sizeof (gshort));
	g_array_append_vals (array, ((struct icalrecurrencetype *)i_cal_object_get_native ((ICalObject *)recur))->by_month, I_CAL_BY_MONTH_SIZE);
	return array;</custom>
    </method>
    <method name="i_cal_recurrence_set_by_month_array" corresponds="CUSTOM" kind="set" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <parameter type="GArray *" name="values" annotation="element-type gshort" comment="The array of values"/>
        <comment>Sets the by_month array in @recur at once. The array size can be less than I_CAL_BY_MONTH_SIZE. Shorter arrays are terminated with I_CAL_RECURRENCE_ARRAY_MAX value, longer arrays are truncated.</comment>
        <custom>    struct icalrecurrencetype *rt;
    guint ii;

    g_return_if_fail(recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur));
    g_return_if_fail(values != NULL);

    rt = (struct icalrecurrencetype *)i_cal_object_get_native((ICalObject *)recur);
    g_return_if_fail(rt != NULL);

    for(ii = 0; ii &lt; values-&gt;len &amp;&amp; ii &lt; I_CAL_BY_MONTH_SIZE; ii++) {
        rt->by_month[ii] = g_array_index(values, gshort, ii);
    }
    if(ii &lt; I_CAL_BY_MONTH_SIZE)
        rt->by_month[ii] = I_CAL_RECURRENCE_ARRAY_MAX;</custom>
    </method>
    <method name="i_cal_recurrence_get_by_month" corresponds="CUSTOM" kind="get" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <parameter type="guint" name="index" comment="The index in by_month of #ICalRecurrence, less than %I_CAL_BY_MONTH_SIZE"/>
        <returns type="gshort" comment="The by_month of #ICalRecurrence at index @index."/>
        <comment>Gets the by_month value at index @index. The index should be less than %I_CAL_BY_MONTH_SIZE.</comment>
        <custom>    g_return_val_if_fail (recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur), I_CAL_RECURRENCE_ARRAY_MAX);
    g_return_val_if_fail (index &lt; I_CAL_BY_MONTH_SIZE, I_CAL_RECURRENCE_ARRAY_MAX);
    return ((struct icalrecurrencetype *)i_cal_object_get_native ((ICalObject *)recur))->by_month[index];</custom>
    </method>
    <method name="i_cal_recurrence_set_by_month" corresponds="CUSTOM" kind="set" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <parameter type="guint" name="index" comment="The index in by_month of #ICalRecurrence"/>
        <parameter type="gshort" name="value" comment="The value to be set into by_month of #ICalRecurrence"/>
        <comment>Sets the by_month array from #ICalRecurrence at the given index. The array size is I_CAL_BY_MONTH_SIZE.</comment>
        <custom>	g_return_if_fail (recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur));
	g_return_if_fail (index &lt; I_CAL_BY_MONTH_SIZE);
	((struct icalrecurrencetype *)i_cal_object_get_native ((ICalObject *)recur))->by_month[index] = value;</custom>
    </method>
    <method name="i_cal_recurrence_get_by_set_pos_array" corresponds="CUSTOM" kind="get" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <returns type="GArray *" annotation="transfer full, element-type gshort" comment="The by_set_pos of #ICalRecurrence."/>
        <comment>Gets the by_set_pos array from #ICalRecurrence. The array size is I_CAL_BY_SETPOS_SIZE.</comment>
        <custom>	GArray *array;
	g_return_val_if_fail (recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur), NULL);
	array = g_array_new (FALSE, FALSE, sizeof (gshort));
	g_array_append_vals (array, ((struct icalrecurrencetype *)i_cal_object_get_native ((ICalObject *)recur))->by_set_pos, I_CAL_BY_SETPOS_SIZE);
	return array;</custom>
    </method>
    <method name="i_cal_recurrence_set_by_set_pos_array" corresponds="CUSTOM" kind="set" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <parameter type="GArray *" name="values" annotation="element-type gshort" comment="The array of values"/>
        <comment>Sets the by_set_pos array in @recur at once. The array size can be less than I_CAL_BY_SETPOS_SIZE. Shorter arrays are terminated with I_CAL_RECURRENCE_ARRAY_MAX value, longer arrays are truncated.</comment>
        <custom>    struct icalrecurrencetype *rt;
    guint ii;

    g_return_if_fail(recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur));
    g_return_if_fail(values != NULL);

    rt = (struct icalrecurrencetype *)i_cal_object_get_native((ICalObject *)recur);
    g_return_if_fail(rt != NULL);

    for(ii = 0; ii &lt; values-&gt;len &amp;&amp; ii &lt; I_CAL_BY_SETPOS_SIZE; ii++) {
        rt->by_set_pos[ii] = g_array_index(values, gshort, ii);
    }
    if(ii &lt; I_CAL_BY_SETPOS_SIZE)
        rt->by_set_pos[ii] = I_CAL_RECURRENCE_ARRAY_MAX;</custom>
    </method>
    <method name="i_cal_recurrence_get_by_set_pos" corresponds="CUSTOM" kind="get" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <parameter type="guint" name="index" comment="The index in by_set_pos of #ICalRecurrence, less than %I_CAL_BY_SETPOS_SIZE"/>
        <returns type="gshort" comment="The by_week_no of #ICalRecurrence at index @index."/>
        <comment>Gets the by_set_pos value at index @index. The index should be less than %I_CAL_BY_SETPOS_SIZE.</comment>
        <custom>    g_return_val_if_fail (recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur), I_CAL_RECURRENCE_ARRAY_MAX);
    g_return_val_if_fail (index &lt; I_CAL_BY_SETPOS_SIZE, I_CAL_RECURRENCE_ARRAY_MAX);
    return ((struct icalrecurrencetype *)i_cal_object_get_native ((ICalObject *)recur))->by_set_pos[index];</custom>
    </method>
    <method name="i_cal_recurrence_set_by_set_pos" corresponds="CUSTOM" kind="set" since="1.0">
        <parameter type="ICalRecurrence *" name="recur" comment="The #ICalRecurrence"/>
        <parameter type="guint" name="index" comment="The index in by_set_pos of #ICalRecurrence"/>
        <parameter type="gshort" name="value" comment="The value to be set into by_set_pos of #ICalRecurrence"/>
        <comment>Sets the by_set_pos array from #ICalRecurrence at the given index. The array size is I_CAL_BY_SETPOS_SIZE.</comment>
        <custom>	g_return_if_fail (recur != NULL &amp;&amp; I_CAL_IS_RECURRENCE (recur));
	g_return_if_fail (index &lt; I_CAL_BY_SETPOS_SIZE);
	((struct icalrecurrencetype *)i_cal_object_get_native ((ICalObject *)recur))->by_set_pos[index] = value;</custom>
    </method>
</structure>
